<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>学习Python | leccxx-blogs</title><meta name="author" content="leccxx,25225ccxx@gmail.com"><meta name="copyright" content="leccxx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习python的计划初步规划 计划的时间为2~3个月（开始时间为2024年11月20日到2025年1月20日或者2025年2月20日） 至少要达到中阶左右水平  12345678910111213141516《Python编程从入门到实践（第2版）》：Python入门基础，建议完成书中的项目。《代码整洁之道》：学习良好的代码风格和实践，培养编程规范。数据结构与算法入门《算法（第4版）》：了解常用"><meta property="og:type" content="article"><meta property="og:title" content="学习Python"><meta property="og:url" content="https://leccxx-maker.github.io/ccxx/2025/11/19/%E5%AD%A6%E4%B9%A0python/index.html"><meta property="og:site_name" content="leccxx-blogs"><meta property="og:description" content="学习python的计划初步规划 计划的时间为2~3个月（开始时间为2024年11月20日到2025年1月20日或者2025年2月20日） 至少要达到中阶左右水平  12345678910111213141516《Python编程从入门到实践（第2版）》：Python入门基础，建议完成书中的项目。《代码整洁之道》：学习良好的代码风格和实践，培养编程规范。数据结构与算法入门《算法（第4版）》：了解常用"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg"><meta property="article:published_time" content="2025-11-19T16:00:00.000Z"><meta property="article:modified_time" content="2025-11-30T14:30:46.211Z"><meta property="article:author" content="leccxx"><meta property="article:tag" content="练习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "学习Python",
  "url": "https://leccxx-maker.github.io/ccxx/2025/11/19/%E5%AD%A6%E4%B9%A0python/",
  "image": "https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg",
  "datePublished": "2025-11-19T16:00:00.000Z",
  "dateModified": "2025-11-30T14:30:46.211Z",
  "author": [
    {
      "@type": "Person",
      "name": "leccxx",
      "url": "https://leccxx-maker.github.io/ccxx"
    }
  ]
}</script><link rel="shortcut icon" href="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/favicon/favicon-16x16.png"><link rel="canonical" href="https://leccxx-maker.github.io/ccxx/2025/11/19/%E5%AD%A6%E4%B9%A0python/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/ccxx/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",()=>{void 0===t.get("theme")&&(e.matches?o():a())})}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/ccxx/",algolia:void 0,localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"Copy Successful",error:"Copy Failed",noSupport:"Browser Not Supported"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"Just now",min:"minutes ago",hour:"hours ago",day:"days ago",month:"months ago"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js",buttonText:"Load More"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"学习Python",isHighlightShrink:!0,isToc:!0,pageType:"post"}</script><style>@media screen and (max-width:768px){#page-header{height:55vh!important;background-size:cover!important;background-position:center!important;background-attachment:scroll!important}#site-title{font-size:1.8rem!important;line-height:1.2!important}#site-subtitle{font-size:1rem!important;opacity:.85!important}#content-inner{padding:12px!important}.card-widget,.recent-post-item{border-radius:14px!important;margin-bottom:14px!important}.post-content img{max-width:100%!important;height:auto!important;border-radius:8px}}</style><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image:url(https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/megalith-7683754.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/avatar/avatar.jpg" onerror='this.onerror=null,this.src="/ccxx/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/ccxx/archives/"><div class="headline">Articles</div><div class="length-num">5</div></a><a href="/ccxx/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/ccxx/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ccxx/"><i class="fa-fw fas fa-house-user"></i><span> home</span></a></div><div class="menus_item"><a class="site-page" href="/ccxx/archives/"><i class="fa-fw fas fa-box-open"></i><span> archives</span></a></div><div class="menus_item"><a class="site-page" href="/ccxx/tags/"><i class="fa-fw fas fa-hashtag"></i><span> tags</span></a></div><div class="menus_item"><a class="site-page" href="/ccxx/categories/"><i class="fa-fw fas fa-layer-group"></i><span> categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/ccxx/"><span class="site-name">leccxx-blogs</span></a><a class="nav-page-title" href="/ccxx/"><span class="site-name">学习Python</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ccxx/"><i class="fa-fw fas fa-house-user"></i><span> home</span></a></div><div class="menus_item"><a class="site-page" href="/ccxx/archives/"><i class="fa-fw fas fa-box-open"></i><span> archives</span></a></div><div class="menus_item"><a class="site-page" href="/ccxx/tags/"><i class="fa-fw fas fa-hashtag"></i><span> tags</span></a></div><div class="menus_item"><a class="site-page" href="/ccxx/categories/"><i class="fa-fw fas fa-layer-group"></i><span> categories</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">学习Python</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-11-19T16:00:00.000Z" title="Created 2025-11-20 00:00:00">2025-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-30T14:30:46.211Z" title="Updated 2025-11-30 22:30:46">2025-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/ccxx/categories/Python/">Python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="学习python的计划"><a href="#学习python的计划" class="headerlink" title="学习python的计划"></a>学习python的计划</h1><h2 id="初步规划"><a href="#初步规划" class="headerlink" title="初步规划"></a>初步规划</h2><ul><li>计划的时间为2~3个月（开始时间为2024年11月20日到2025年1月20日或者2025年2月20日）</li><li>至少要达到中阶左右水平</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">《Python编程从入门到实践（第2版）》：Python入门基础，建议完成书中的项目。</span><br><span class="line">《代码整洁之道》：学习良好的代码风格和实践，培养编程规范。</span><br><span class="line">数据结构与算法入门</span><br><span class="line">《算法（第4版）》：了解常用的数据结构和算法，如排序、查找、递归等。</span><br><span class="line">《数据结构与算法 Python语言实现》：结合Python语言理解数据结构和算法的基本实现。</span><br><span class="line">操作系统和系统基础</span><br><span class="line">数学基础</span><br><span class="line">《高等数学（上下册）》（同济大学数学系编）：数学基础，尤其是微积分知识。</span><br><span class="line">《线性代数及其应用》：理解矩阵和向量，为机器学习和数据分析中的线性代数运算奠定基础。</span><br><span class="line">计算机基础原理</span><br><span class="line">《编码 隐匿在计算机软硬件背后的语言》：了解编码、二进制、数字表示等概念，构建计算机内部原理的基本理解。</span><br><span class="line">Python和编程进阶</span><br><span class="line">《流畅的Python》：进一步理解Python语言特性，掌握高级用法。</span><br><span class="line">《Python3网络爬虫开发实战（第2版）》：学习网络爬虫，掌握网络数据采集和处理方法。</span><br><span class="line">算法与数据结构进阶</span><br><span class="line">《离散数学及其应用》：学习离散数学中的逻辑、图论、组合数学等内容，夯实算法和数据结构的理论。</span><br></pre></td></tr></table></figure><p><strong>推荐的初阶学习顺序</strong><br><strong>数学基础：</strong><br><strong>先学习 《高等数学》 的基本微积分内容，帮助理解连续变化和渐进增长等概念。</strong><br><strong>接着学习 《线性代数及其应用》，理解向量、矩阵等基础，这对后续的数据分析和算法理解也有帮助。</strong><br><strong>数据结构与算法：</strong><br><strong>在具备数学基础后，进入 《算法（第4版）》 和 《数据结构与算法 Python语言实现》。</strong><br><strong>学习时，可以结合实践和简单的算法实现，把数学知识应用到编程中。</strong><br><strong>这种顺序将使你在数学和算法学习之间形成良好的衔接，提升理解力和应用能力。</strong></p><ul><li>了解python生态</li><li>实战项目</li></ul><h2 id="每日总结"><a href="#每日总结" class="headerlink" title="每日总结"></a>每日总结</h2><h3 id="2024-11-20"><a href="#2024-11-20" class="headerlink" title="2024&#x2F;11&#x2F;20"></a>2024&#x2F;11&#x2F;20</h3><p>重新学习了python，在B站上面找了一个讲的还不错的视频观看，视频链接为<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wD4y1o7AS?t=2.1&p=25">python入门到精通</a></p><ul><li>学习了比较多的基础知识，例如用python进行进制之间的转换，认识了数据类型和保留字，算术运算符、比较运算符、逻辑运算符、位运算符，以及它们之间的优先级。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 哲学</span></span><br><span class="line"><span class="keyword">import</span> this</span><br><span class="line"><span class="built_in">print</span>(this)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># python 保留字</span></span><br><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br><span class="line"><span class="comment"># python有多少个保留字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(keyword.kwlist))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 算数运算符 + - * / // % **</span></span><br><span class="line"><span class="comment"># 比较运算符 &gt; &lt; == &gt;= &lt;= !=</span></span><br><span class="line"><span class="comment"># 逻辑运算符 and 与 or 或  not 非</span></span><br><span class="line"><span class="comment"># 位运算符 &amp; 位与  | 位或  ^ 异或  ~取反  &lt;&lt;  左移位   &gt;&gt; 右移位 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">算术运算符</span><br><span class="line">+：加法</span><br><span class="line">-：减法</span><br><span class="line">*：乘法</span><br><span class="line">/：除法（返回浮点数结果，即使整除）</span><br><span class="line">//：整除（只保留商的整数部分）</span><br><span class="line">%：取模（返回余数）</span><br><span class="line">**：幂运算（指数）</span><br><span class="line">比较运算符</span><br><span class="line">&gt;：大于</span><br><span class="line">&lt;：小于</span><br><span class="line">==：等于（注意是比较相等，不是赋值）</span><br><span class="line">&gt;=：大于等于</span><br><span class="line">&lt;=：小于等于</span><br><span class="line">!=：不等于</span><br><span class="line">逻辑运算符</span><br><span class="line">and：逻辑与（当且仅当两个条件均为真时，结果为真）</span><br><span class="line">or：逻辑或（当至少一个条件为真时，结果为真）</span><br><span class="line">not：逻辑非（将条件取反）</span><br><span class="line">位运算符</span><br><span class="line">&amp;：按位与（两位均为 1 时，结果为 1，否则为 0）</span><br><span class="line">|：按位或（两位至少有一位为 1 时，结果为 1）</span><br><span class="line">^：按位异或（两位不同则为 1，相同则为 0）</span><br><span class="line">~：按位取反（将每个位取反）</span><br><span class="line">&lt;&lt;：左移位（按位左移，左边丢弃，右边补 0，相当于乘以 2 的 n 次方）</span><br><span class="line">&gt;&gt;：右移位（按位右移，右边丢弃，左边根据符号位补 0 或 1，相当于除以 2 的 n 次方）</span><br></pre></td></tr></table></figure><ul><li>重点有字符串切片，例如[-3, -2],索引为-2的字符不取。python的编程规范等等</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">python编程规范主要参考PEP8</span><br><span class="line">1. 代码格式</span><br><span class="line">缩进</span><br><span class="line">使用 4 个空格来缩进代码。</span><br><span class="line">禁止使用 Tab 键混用缩进（可以通过 IDE 设置）。</span><br><span class="line">每行字符数限制</span><br><span class="line">每行代码建议不超过 79 个字符。</span><br><span class="line">文档字符串或注释建议不超过 72 个字符。</span><br><span class="line">空行</span><br><span class="line">顶级函数和类定义之间用两行空行隔开。</span><br><span class="line">类中方法之间用一行空行隔开。</span><br><span class="line">函数中逻辑段落之间用一行空行隔开。</span><br><span class="line">空格使用</span><br><span class="line">运算符两侧使用单个空格（推荐）：</span><br><span class="line">python</span><br><span class="line">a = b + c</span><br><span class="line">不要在括号内部加空格：</span><br><span class="line">python</span><br><span class="line"># 正确：</span><br><span class="line">my_func(a, b)</span><br><span class="line"></span><br><span class="line"># 错误：</span><br><span class="line">my_func( a, b )</span><br><span class="line">2. 命名规范</span><br><span class="line">变量命名</span><br><span class="line">使用 小写字母和下划线（snake_case）：</span><br><span class="line">python</span><br><span class="line">total_count = 10</span><br><span class="line">函数命名</span><br><span class="line">函数名使用 小写字母和下划线：</span><br><span class="line">python</span><br><span class="line">def calculate_area():</span><br><span class="line">    pass</span><br><span class="line">类命名</span><br><span class="line">使用 首字母大写的驼峰命名法（PascalCase）：</span><br><span class="line">python</span><br><span class="line">class MyClass:</span><br><span class="line">    pass</span><br><span class="line">常量命名</span><br><span class="line">使用 全大写字母和下划线（UPPER_SNAKE_CASE）：</span><br><span class="line">python</span><br><span class="line">MAX_RETRIES = 5</span><br><span class="line">私有变量或方法</span><br><span class="line">使用单个下划线开头：</span><br><span class="line">python</span><br><span class="line">_private_variable = 42</span><br><span class="line">def _private_method():</span><br><span class="line">    pass</span><br><span class="line">3. 注释</span><br><span class="line">单行注释</span><br><span class="line">使用 #，并在 # 后留一个空格：</span><br><span class="line">python</span><br><span class="line"># 这是一个单行注释</span><br><span class="line">total = 10  # 这是变量的含义</span><br><span class="line">多行注释</span><br><span class="line">使用多行 # 注释块或文档字符串：</span><br><span class="line">python</span><br><span class="line"># 这是一个多行注释</span><br><span class="line"># 用于描述较复杂的逻辑。</span><br><span class="line">文档字符串</span><br><span class="line">使用 &quot;&quot;&quot; 来注释模块、类和函数：</span><br><span class="line">python</span><br><span class="line">def my_function():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    这是一个函数的文档字符串。</span><br><span class="line">    作用：描述函数的功能和用途。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line">4. 代码结构</span><br><span class="line">导入顺序</span><br><span class="line">导入分为三部分，按以下顺序排列并用空行隔开：</span><br><span class="line"></span><br><span class="line">标准库模块</span><br><span class="line">第三方模块</span><br><span class="line">本地模块或自定义模块</span><br><span class="line">python</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">from my_project.utils import my_function</span><br><span class="line">每行只导入一个模块</span><br><span class="line">python</span><br><span class="line"># 正确：</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 错误：</span><br><span class="line">import os, sys</span><br><span class="line">5. 异常处理</span><br><span class="line">使用 try-except 块捕获异常：</span><br><span class="line"></span><br><span class="line">python</span><br><span class="line">复制代码</span><br><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(f&quot;Error: &#123;e&#125;&quot;)</span><br><span class="line">不要使用裸 except，而是指定异常类型：</span><br><span class="line"></span><br><span class="line">python</span><br><span class="line"># 正确：</span><br><span class="line">try:</span><br><span class="line">    pass</span><br><span class="line">except ValueError:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 错误：</span><br><span class="line">try:</span><br><span class="line">    pass</span><br><span class="line">except:</span><br><span class="line">    pass</span><br><span class="line">6. 其他建议</span><br><span class="line">遵循 Python 的 &quot;显式优于隐式&quot; 和 &quot;简单优于复杂&quot; 原则（来自 Python 之禅 import this）。</span><br><span class="line">避免滥用全局变量。</span><br><span class="line">尽量保持函数短小，每个函数只做一件事情。</span><br><span class="line">使用类型注解：</span><br><span class="line">python</span><br><span class="line">def add_numbers(a: int, b: int) -&gt; int:</span><br><span class="line">    return a + b</span><br><span class="line">7. 工具辅助</span><br><span class="line">使用自动化工具检查代码风格，例如：</span><br><span class="line">flake8：静态检查代码是否符合 PEP 8。</span><br><span class="line">black：自动格式化代码。</span><br><span class="line">pylint：提供代码质量分析。</span><br></pre></td></tr></table></figure><ul><li>eval函数、input函数、print函数、id函数、round函数，len函数等等</li></ul><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E6%80%BB%E7%BB%93%E8%A1%A8.png" alt="image-20241120215022726"></p><h3 id="2024-11-21"><a href="#2024-11-21" class="headerlink" title="2024&#x2F;11&#x2F;21"></a>2024&#x2F;11&#x2F;21</h3><p>今天没学习多少，有事耽搁了。（比较重要的事）</p><p>python学习了以下内容</p><ul><li>顺序结构</li><li>选择结构</li><li>双分支结构</li><li>多分支结构</li></ul><h3 id="2024-11-22"><a href="#2024-11-22" class="headerlink" title="2024&#x2F;11&#x2F;22"></a>2024&#x2F;11&#x2F;22</h3><p>今天在解决一个编程问题（打印一个菱形）时遇到的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印一个菱形</span></span><br><span class="line">rows = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">range_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>)]</span><br><span class="line">range_list.reverse()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range_list:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chatgpt优化的代码</span></span><br><span class="line">rows = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印上半部分和下半部分</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):  <span class="comment"># 倒序从 rows-1 开始</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 封装成一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_diamond</span>(<span class="params">rows</span>):</span><br><span class="line">    <span class="comment"># 打印菱形的上半部分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 打印菱形的下半部分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">print_diamond(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空心菱形</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hollow_diamond</span>(<span class="params">rows</span>):</span><br><span class="line">    <span class="comment"># 上半部分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27; &#x27;</span> * (<span class="number">2</span> * i - <span class="number">3</span>) + <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下半部分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27; &#x27;</span> * (<span class="number">2</span> * i - <span class="number">3</span>) + <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">print_hollow_diamond(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><ul><li><code>reverse()</code>函数是原地修改列表，而不是返回一个新的列表。（例如：列表<code>x_list = y_list.reverse()</code> 打印x_list返回的是None）</li></ul><p>如果需要获取反转后的列表，可用切片方法或者<code>reversed()</code>函数。</p><ul><li>切片方法会反转一个新的列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印一个菱形</span></span><br><span class="line">rows = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">range_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range_list[::-<span class="number">1</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span> * (rows - i) + <span class="string">&#x27;*&#x27;</span> * (<span class="number">2</span> * i - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><ul><li><code>reversed()</code> 函数返回一个反转的迭代器，可以用 <code>list()</code> 转换为列表：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">range_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>)]</span><br><span class="line">x_list = <span class="built_in">list</span>(<span class="built_in">reversed</span>(range_list))</span><br><span class="line"><span class="built_in">print</span>(x_list)</span><br></pre></td></tr></table></figure><ul><li>使用<code>reverse()</code>的场景</li></ul><p><code>reverse()</code> 是一个<strong>就地修改</strong>（in-place modification）的方法，它直接改变原列表的顺序而不返回新的列表。它适合以下场景：</p><ol><li><strong>需要就地修改原列表的顺序</strong><br>如果你不需要保留原列表的顺序，也不需要新创建一个反转后的列表，而是直接修改当前列表，使用 <code>reverse()</code> 是最有效的选择。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">my_list.reverse()  <span class="comment"># 直接修改列表</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出：[5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>性能优化</strong></li></ol><p>​ <code>reverse()</code> 是原地操作，消耗的内存更少，适合在性能要求较高的情况下使用。</p><pre><code>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">big_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000000</span>))</span><br><span class="line">big_list.reverse()  <span class="comment"># 原地修改，不生成新列表</span></span><br></pre></td></tr></table></figure>
</code></pre><p>相比之下，切片 <code>[::-1]</code> 会创建一个新列表，占用额外内存。</p><ol start="3"><li><strong>在不需要返回值的场景中</strong><br>当反转列表只是一个步骤，并不需要进一步处理反转后的列表：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>]</span><br><span class="line">names.reverse()  <span class="comment"># 原地反转</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Reversed names:&quot;</span>, names)</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>简化逻辑</strong><br>在特定算法中，需要反转列表以简化操作时，用 <code>reverse()</code> 可以让代码更清晰：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转后就地进行其他操作</span></span><br><span class="line">numbers.reverse()</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="built_in">print</span>(num)  <span class="comment"># 依次打印 5, 4, 3, 2, 1</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>注意事项</strong><br><strong>不可链式调用</strong> <code>reverse()</code> 返回 <code>None</code>，不能像某些其他方法那样链式调用：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 错误：不能链式调用</span></span><br><span class="line">reversed_list = my_list.reverse().append(<span class="number">4</span>)  <span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure><p><strong>不可用于不可变数据类型</strong> <code>reverse()</code> 只能用于列表，像字符串、元组等不可变类型需要用其他方式反转，例如 <code>[::-1]</code> 或 <code>reversed()</code>。</p><ol start="6"><li><strong>总结</strong></li></ol><ul><li><strong>用 <code>reverse()</code></strong>：当你只想就地修改列表顺序，并不需要新列表。</li><li><strong>用 <code>[::-1]</code> 或 <code>reversed()</code></strong>：当你需要保留原列表或返回一个新的反转版本。</li></ul><h3 id="2024-11-23"><a href="#2024-11-23" class="headerlink" title="2024&#x2F;11&#x2F;23"></a>2024&#x2F;11&#x2F;23</h3><ul><li>python3.11新特性match … case…结构</li><li>循环结构有两种：for遍历循环和while无限循环</li></ul><h4 id="九九乘法表（chatgpt）"><a href="#九九乘法表（chatgpt）" class="headerlink" title="九九乘法表（chatgpt）"></a>九九乘法表（chatgpt）</h4><h5 id="实现1-基本九九乘法表"><a href="#实现1-基本九九乘法表" class="headerlink" title="实现1 基本九九乘法表"></a>实现1 基本九九乘法表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):				<span class="comment"># 外层循环控制行数</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):		<span class="comment"># 内层循环控制每一行的列数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>*<span class="subst">&#123;i&#125;</span>=<span class="subst">&#123;i * j&#125;</span>&quot;</span>, end=<span class="string">&#x27;\t&#x27;</span>)			<span class="comment"># 用 f-string 格式化输出 打印每个乘法表达式</span></span><br><span class="line">    <span class="built_in">print</span>()			<span class="comment"># 换行</span></span><br></pre></td></tr></table></figure><h5 id="实现2-对齐九九乘法表"><a href="#实现2-对齐九九乘法表" class="headerlink" title="实现2 对齐九九乘法表"></a>实现2 对齐九九乘法表</h5><p>通过指定每个单元格的宽度，让表格整齐对齐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>*<span class="subst">&#123;i&#125;</span>=<span class="subst">&#123;i * j:<span class="number">2</span>&#125;</span>&quot;</span>, end=<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># `:2` 表示结果占 2 个字符宽度</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h5 id="实现3-封装为函数"><a href="#实现3-封装为函数" class="headerlink" title="实现3 封装为函数"></a>实现3 封装为函数</h5><p>将九九乘法表封装为函数，支持灵活调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_multiplication_table</span>(<span class="params">n=<span class="number">9</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印 n*n 的乘法表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>*<span class="subst">&#123;i&#125;</span>=<span class="subst">&#123;i * j:<span class="number">2</span>&#125;</span>&quot;</span>, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">print_multiplication_table()</span><br></pre></td></tr></table></figure><h5 id="实现4-动态可扩展乘法表"><a href="#实现4-动态可扩展乘法表" class="headerlink" title="实现4 动态可扩展乘法表"></a>实现4 动态可扩展乘法表</h5><p>为支持自定义范围（如：12X12或者更多），扩展功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_multiplication_table</span>(<span class="params">rows, cols=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印自定义行数和列数的乘法表&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> cols <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cols = rows  <span class="comment"># 如果列数未指定，默认为方形表</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">min</span>(i, cols) + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>*<span class="subst">&#123;i&#125;</span>=<span class="subst">&#123;i * j:<span class="number">2</span>&#125;</span>&quot;</span>, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数，打印标准 9×9</span></span><br><span class="line">print_multiplication_table(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数，打印 12×12</span></span><br><span class="line">print_multiplication_table(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h5 id="实现5-结果保存到文件"><a href="#实现5-结果保存到文件" class="headerlink" title="实现5 结果保存到文件"></a>实现5 结果保存到文件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_multiplication_table_to_file</span>(<span class="params">filepath, n=<span class="number">9</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将乘法表保存到文件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                f.write(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>*<span class="subst">&#123;i&#125;</span>=<span class="subst">&#123;i * j:<span class="number">2</span>&#125;</span>\t&quot;</span>)</span><br><span class="line">            f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存到文件</span></span><br><span class="line">save_multiplication_table_to_file(<span class="string">&quot;multiplication_table.txt&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>实现原则：<ul><li>简洁但不失可读性，优先使用 <code>f-string</code>。</li><li>考虑代码的扩展性和灵活性，封装为函数是我常用的方式。</li><li>输出美观，尽量对齐。</li></ul></li><li>常用代码：<ul><li>如果是一次性使用，我会用实现 1 或 2；如果需要多次使用，我会用实现 3 或 4，甚至实现 5 来保存结果。</li></ul></li></ol><h4 id="猜数游戏-chatgpt"><a href="#猜数游戏-chatgpt" class="headerlink" title="猜数游戏(chatgpt)"></a>猜数游戏(chatgpt)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">guess_number_game</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;猜数字游戏&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 累加猜测次数</span></span><br><span class="line">    attempts = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机生成目标数字</span></span><br><span class="line">    random_number = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;欢迎来到猜数字游戏！目标数字是 1 到 100 之间的整数。&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;试着猜猜看吧！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            user_number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入您猜的数字：&quot;</span>))</span><br><span class="line">            attempts += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> user_number &gt; random_number:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;您所猜的数字大了。&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> user_number &lt; random_number:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;您猜的数字小了。&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;恭喜您猜对了！目标数字是 <span class="subst">&#123;random_number&#125;</span>。&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;您一共猜了 <span class="subst">&#123;attempts&#125;</span> 次。&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;请输入一个有效的整数！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始游戏</span></span><br><span class="line">guess_number_game()</span><br></pre></td></tr></table></figure><h3 id="2024-11-24"><a href="#2024-11-24" class="headerlink" title="2024&#x2F;11&#x2F;24"></a>2024&#x2F;11&#x2F;24</h3><p>今日未能坚持学习，明天要去成都玩几天。回来复习以下前面的知识再学习。加油！</p><h3 id="2024-12-02"><a href="#2024-12-02" class="headerlink" title="2024&#x2F;12&#x2F;02"></a>2024&#x2F;12&#x2F;02</h3><p>已复习（又去玩了两天 后面不能去玩了）</p><h3 id="2024-12-04"><a href="#2024-12-04" class="headerlink" title="2024&#x2F;12&#x2F;04"></a>2024&#x2F;12&#x2F;04</h3><p>善用列表推导式(python内部对推导式进行了优化)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机数列表</span></span><br><span class="line">random_list = [random.randint(<span class="number">0</span>, <span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 enumerate 构造字典</span></span><br><span class="line">index_random_map = &#123;index: item <span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(random_list, <span class="number">1</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Random List:&quot;</span>, random_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Index to Random Map:&quot;</span>, index_random_map)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2024-12-11"><a href="#2024-12-11" class="headerlink" title="2024&#x2F;12&#x2F;11"></a>2024&#x2F;12&#x2F;11</h3><p>前段时间属于堕落贪玩了。</p><p>打印二维列表（表格数据）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二维列表</span></span><br><span class="line"><span class="comment"># 创建一个二维列表</span></span><br><span class="line"></span><br><span class="line">lst = [</span><br><span class="line">    [<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>, <span class="string">&#x27;同比&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;111&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;102&#x27;</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(item, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()     <span class="comment"># 换行</span></span><br></pre></td></tr></table></figure><p>更优雅的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二维列表</span></span><br><span class="line"><span class="comment"># 创建一个二维列表</span></span><br><span class="line"></span><br><span class="line">lst = [</span><br><span class="line">    [<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>, <span class="string">&#x27;同比&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;111&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;102&#x27;</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\t&#x27;</span>.join(row))  <span class="comment"># 使用 tab 分隔</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lst = [</span><br><span class="line">    [<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>, <span class="string">&#x27;同比&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;121&#x27;</span>, <span class="string">&#x27;111&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;101&#x27;</span>, <span class="string">&#x27;102&#x27;</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为一个包含字符串的列表</span></span><br><span class="line">formatted_rows = [<span class="string">&#x27;\t&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> lst]</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> formatted_rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure><h3 id="2024-12-12"><a href="#2024-12-12" class="headerlink" title="2024&#x2F;12&#x2F;12"></a>2024&#x2F;12&#x2F;12</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题1： 基本数据结构操作</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个函数，输入一个字符串，返回字符串中每个字符出现的次数（频率）。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_str</span>():</span><br><span class="line">    <span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入一个字符串: &quot;</span>)</span><br><span class="line">    key_str = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">dict</span>.fromkeys(<span class="built_in">str</span>))</span><br><span class="line">    value = &#123;i: <span class="built_in">str</span>.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> key_str&#125;</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题2：控制结构(暴力解法)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个函数，输入一个整数列表 nums 和一个目标值 target，返回列表中两个数之和等于目标值的索引。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">two_num</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                <span class="keyword">return</span> [i, j]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">x = two_num(nums, target)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题2：控制结构</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个函数，输入一个整数列表 nums 和一个目标值 target，返回列表中两个数之和等于目标值的索引。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">two_sum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="comment"># 创建一个空字典来存储数值及其对应的索引</span></span><br><span class="line">    num_to_index = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        complement = target - num  <span class="comment"># 计算目标值的补数</span></span><br><span class="line">        <span class="keyword">if</span> complement <span class="keyword">in</span> num_to_index:  <span class="comment"># 如果补数已经在字典中，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> [num_to_index[complement], i]</span><br><span class="line">        num_to_index[num] = i  <span class="comment"># 否则，将当前数及索引存入字典</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 如果没有找到，返回 None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">x = two_sum(nums, target)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问题2：控制结构(哈希表)更优解法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个函数，输入一个整数列表 nums 和一个目标值 target，返回列表中两个数之和等于目标值的索引。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个递归函数，计算给定数字的阶乘。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 递归公式</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试代码</span></span><br><span class="line">num = <span class="number">5</span></span><br><span class="line">result = factorial(num)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span>! = <span class="subst">&#123;result&#125;</span>&quot;</span>)  <span class="comment"># 输出 5! = 120</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># 使用循环累乘</span></span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="递归和迭代"><a href="#递归和迭代" class="headerlink" title="递归和迭代"></a>递归和迭代</h4><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3.png" alt="image-20241213015005310"></p><h3 id="2024-12-14"><a href="#2024-12-14" class="headerlink" title="2024&#x2F;12&#x2F;14"></a>2024&#x2F;12&#x2F;14</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写一个程序，要求用户输入一个整数 n，输出从 1 到 n 所有整数的平方。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_square</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数: &#x27;</span>))</span><br><span class="line">    square = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> square</span><br><span class="line"></span><br><span class="line">x = print_square()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写一个函数，将两个字典合并。如果存在相同的键，则值相加。（这题不是自己想出来的，这一块的基础知识较为薄弱）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_dict</span>(<span class="params">dict1, dict2</span>):</span><br><span class="line">    <span class="comment"># 获取唯一的键</span></span><br><span class="line">    all_keys = <span class="built_in">set</span>(dict1) | <span class="built_in">set</span>(dict2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建新的字典，相同键的值相加，不同键的值保持不变</span></span><br><span class="line">    merged_dict = &#123;key: dict1.get(key, <span class="number">0</span>) + dict2.get(key, <span class="number">0</span>) <span class="keyword">for</span> key <span class="keyword">in</span> all_keys&#125;</span><br><span class="line">    <span class="built_in">print</span>(merged_dict)</span><br><span class="line"></span><br><span class="line">dict1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">dict2 = &#123;<span class="string">&quot;b&quot;</span>: <span class="number">3</span>, <span class="string">&quot;c&quot;</span>: <span class="number">4</span>, <span class="string">&quot;d&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">merge_dict(dict1, dict2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用递归实现斐波那契数列，返回第 n 个斐波那契数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">7</span></span><br><span class="line">x = fibonacci(n)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划 优化 动态规划实现斐波那契数列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    fib = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    fib[<span class="number">1</span>], fib[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">        fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> fib[n]</span><br><span class="line"></span><br><span class="line">n = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(fibonacci(n))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要从文件 input.txt 中读取每一行，将其内容反转后写入 output.txt。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_lines</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infile, <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line">            outfile.write(line.strip()[::-<span class="number">1</span>] + <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># 反转并写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 input.txt 文件内容：</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># python is great</span></span><br><span class="line"></span><br><span class="line">reverse_lines(<span class="string">&#x27;input.txt&#x27;</span>, <span class="string">&#x27;output.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># output.txt 输出：</span></span><br><span class="line"><span class="comment"># dlrow olleh</span></span><br><span class="line"><span class="comment"># taerg si nohtyp</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个程序完成以下任务：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">计算所有学生的平均分。</span></span><br><span class="line"><span class="string">按照分数从高到低排序，返回排序后的列表。</span></span><br><span class="line"><span class="string">找到最高分的学生姓名。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">92</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">87</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;David&quot;</span>, <span class="string">&quot;score&quot;</span>: <span class="number">78</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均分</span></span><br><span class="line">average_score = <span class="built_in">sum</span>(student[<span class="string">&#x27;score&#x27;</span>] <span class="keyword">for</span> student <span class="keyword">in</span> students) / <span class="built_in">len</span>(students)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;平均分：<span class="subst">&#123;average_score&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按分数从高到低排序</span></span><br><span class="line">sorted_students = <span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;score&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;排序：<span class="subst">&#123;sorted_students&#125;</span>&quot;</span>)</span><br><span class="line">v </span><br><span class="line">highest_score_student = <span class="built_in">max</span>(students, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最高分学生：<span class="subst">&#123;highest_score_student[<span class="string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2024-12-27"><a href="#2024-12-27" class="headerlink" title="2024&#x2F;12&#x2F;27"></a>2024&#x2F;12&#x2F;27</h3><h4 id="扩展赋值运算符"><a href="#扩展赋值运算符" class="headerlink" title="扩展赋值运算符"></a>扩展赋值运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alpha = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">beta = alpha</span><br><span class="line">beta += [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">beta = beta + [<span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(alpha)</span><br><span class="line"><span class="built_in">print</span>(beta)</span><br><span class="line"><span class="comment"># 这个例子展现了语句beta += foo, beta = beta + foo 在列表语义方面的微妙差异。</span></span><br></pre></td></tr></table></figure><h3 id="2025-2-8"><a href="#2025-2-8" class="headerlink" title="2025&#x2F;2&#x2F;8"></a>2025&#x2F;2&#x2F;8</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入两个数字并计算和、差、积和商</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        add_sum = a + b</span><br><span class="line">        subtract_sum = a - b</span><br><span class="line">        multiply_sum = a * b</span><br><span class="line">        divide_sum = a / b</span><br><span class="line">        <span class="keyword">return</span> add_sum, subtract_sum, multiply_sum, divide_sum</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：除数不能为零&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>(<span class="string">&quot;请输入两个数字（以空格分开）：&quot;</span>).split())</span><br><span class="line">result = calculate(a, b)</span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;和: <span class="subst">&#123;result[<span class="number">0</span>]&#125;</span>, 差: <span class="subst">&#123;result[<span class="number">1</span>]&#125;</span>, 积: <span class="subst">&#123;result[<span class="number">2</span>]&#125;</span>, 商: <span class="subst">&#123;result[<span class="number">3</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  判断奇偶性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_even_or_odd</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;偶数&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;奇数&quot;</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数：&quot;</span>))</span><br><span class="line">result = is_even_or_odd(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;用户输入的是<span class="subst">&#123;result&#125;</span>。&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换列表中的偶数为平方</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replace_square_number</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="keyword">return</span> [x**<span class="number">2</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> x <span class="keyword">for</span> x <span class="keyword">in</span> lst]</span><br><span class="line"></span><br><span class="line">n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">x = replace_square_number(n)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出: [1, 4, 3, 16, 5]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串反转</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_string</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> s[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">n = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line">reversed_n = reverse_string(n)</span><br><span class="line"><span class="built_in">print</span>(reversed_n)  <span class="comment"># 输出: gfedcba</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据分数对学生排序</span></span><br><span class="line"><span class="comment"># 创建学生姓名和分数的字典</span></span><br><span class="line">students = &#123;</span><br><span class="line">    <span class="string">&quot;Alice&quot;</span>: <span class="number">90</span>,</span><br><span class="line">    <span class="string">&quot;Bob&quot;</span>: <span class="number">85</span>,</span><br><span class="line">    <span class="string">&quot;Charlie&quot;</span>: <span class="number">95</span>,</span><br><span class="line">    <span class="string">&quot;David&quot;</span>: <span class="number">88</span>,</span><br><span class="line">    <span class="string">&quot;Eve&quot;</span>: <span class="number">92</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据分数对学生进行降序排序</span></span><br><span class="line">sorted_students = <span class="built_in">sorted</span>(students.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出排序结果</span></span><br><span class="line"><span class="keyword">for</span> name, score <span class="keyword">in</span> sorted_students:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;score&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 斐波那契数列递归</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params"><span class="literal">None</span></span>)  </span><span class="comment"># 缓存结果，避免重复计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入斐波那契数列的项数：&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第 <span class="subst">&#123;n&#125;</span> 项是：<span class="subst">&#123;fibonacci(n)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件读写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_word_frequency</span>(<span class="params">filename</span>):</span><br><span class="line">    word_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            words = line.strip().split()</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">                word_count[word] = word_count.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> word_count</span><br><span class="line"></span><br><span class="line">filename = <span class="built_in">input</span>(<span class="string">&quot;请输入文件名：&quot;</span>)</span><br><span class="line">word_freq = count_word_frequency(filename)</span><br><span class="line"><span class="keyword">for</span> word, count <span class="keyword">in</span> word_freq.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;word&#125;</span>: <span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">number_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> i % <span class="number">5</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(number_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  异常处理</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    number = <span class="built_in">input</span>(<span class="string">&#x27;请输入一个数字：&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        number = <span class="built_in">float</span>(number)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---请重新输入---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;您输入的数字是：<span class="subst">&#123;number&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义类 Rectangle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, width, height</span>):</span><br><span class="line">        <span class="keyword">if</span> width &lt;= <span class="number">0</span> <span class="keyword">or</span> height &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;宽度和高度必须为正数&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.width = width</span><br><span class="line">        <span class="variable language_">self</span>.height = height</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.width * <span class="variable language_">self</span>.height</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (<span class="variable language_">self</span>.width + <span class="variable language_">self</span>.height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line">rect = Rectangle(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;面积: <span class="subst">&#123;rect.area()&#125;</span>, 周长: <span class="subst">&#123;rect.perimeter()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2025-2-21"><a href="#2025-2-21" class="headerlink" title="2025&#x2F;2&#x2F;21"></a>2025&#x2F;2&#x2F;21</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 罗马数字转阿拉伯数字(leecode算法题)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s</span>):</span><br><span class="line">        roman_dict = &#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>&#125;</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="keyword">and</span> roman_dict[s[i]] &lt; roman_dict[s[i + <span class="number">1</span>]]:</span><br><span class="line">                total -= roman_dict[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total += roman_dict[s[i]]</span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># progression</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Progression</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Iterator producing a generic progression.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Default iterator produces the whole numbers 0,1,2, ...</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize current to the first value of the progression.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._current = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_advance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Update self._current to a new value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This should be overridden by a subclass to customize progression.</span></span><br><span class="line"><span class="string">        By convention, if current is set to None, this designates the end of a finite progression.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the next element, or else raise StopIteration error.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._current <span class="keyword">is</span> <span class="literal">None</span>:           <span class="comment"># our convention to end a progression</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer = <span class="variable language_">self</span>._current          <span class="comment"># record current value to return</span></span><br><span class="line">            <span class="variable language_">self</span>._advance()                 <span class="comment"># advance to prepare for next time</span></span><br><span class="line">            <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;By convention, an iterator must return itself as an iterator.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_progression</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Print next n values of the progression.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">str</span>(<span class="built_in">next</span>(<span class="variable language_">self</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArithmeticProgression</span>(<span class="title class_ inherited__">Progression</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Iterator producing an arithmetic progression.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, increment=<span class="number">1</span>, start=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create a new arithmetic progression.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        increment   the fixed constant to add to each term (default 1)</span></span><br><span class="line"><span class="string">        start       the first term of the progression (default 0)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(start)             <span class="comment"># initialize base class</span></span><br><span class="line">        <span class="variable language_">self</span>._increment = increment</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_advance</span>(<span class="params">self</span>):                     <span class="comment"># override inherited version</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Update current value by adding the fixed increment.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._current += <span class="variable language_">self</span>._increment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeometricProgression</span>(<span class="title class_ inherited__">Progression</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Iterator producing a geometric progression.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base=<span class="number">2</span>, start=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create a new geometric progression.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        base   the fixed constant multiplied to each term (default 2)</span></span><br><span class="line"><span class="string">        start  the first term of the progression (default 1)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(start)</span><br><span class="line">        <span class="variable language_">self</span>._base = base</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_advance</span>(<span class="params">self</span>):                     <span class="comment"># override inherited version</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Update current value by multiplying it by the base value.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._current *= <span class="variable language_">self</span>._base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciProgression</span>(<span class="title class_ inherited__">Progression</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Iterator producing a generalized Fibonacci progression.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first=<span class="number">0</span>, second=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create a new fibonacci progression.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        first    the first term of the progression (default 0)</span></span><br><span class="line"><span class="string">        second   the second term of the progression (default 1)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(first)              <span class="comment"># start progression at first</span></span><br><span class="line">        <span class="variable language_">self</span>._prev = second - first          <span class="comment"># fictitious value preceding the first</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_advance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Update current value by taking sum of previous two.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._prev, <span class="variable language_">self</span>._current = <span class="variable language_">self</span>._current, <span class="variable language_">self</span>._prev + <span class="variable language_">self</span>._current</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Default progression:&#x27;</span>)</span><br><span class="line">    Progression().print_progression(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Arithmetic progression with increment 5:&#x27;</span>)</span><br><span class="line">    ArithmeticProgression(<span class="number">5</span>).print_progression(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Arithmetic progression with increment 5 and start 2:&#x27;</span>)</span><br><span class="line">    ArithmeticProgression(<span class="number">5</span>, <span class="number">2</span>).print_progression(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Geometric progression with default base:&#x27;</span>)</span><br><span class="line">    GeometricProgression().print_progression(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Geometric progression with base 3:&#x27;</span>)</span><br><span class="line">    GeometricProgression(<span class="number">3</span>).print_progression(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Fibonacci progression with default start values:&#x27;</span>)</span><br><span class="line">    FibonacciProgression().print_progression(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Fibonacci progression with start values 4 and 6:&#x27;</span>)</span><br><span class="line">    FibonacciProgression(<span class="number">4</span>, <span class="number">6</span>).print_progression(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2025-2-23"><a href="#2025-2-23" class="headerlink" title="2025&#x2F;2&#x2F;23"></a>2025&#x2F;2&#x2F;23</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最长公共前缀</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">strs</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs[<span class="number">0</span>])):</span><br><span class="line">        char = strs[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(s) <span class="keyword">or</span> s[i] != char:</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串 s ，判断字符串是否有效。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">有效字符串需满足：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">左括号必须用相同类型的右括号闭合。</span></span><br><span class="line"><span class="string">左括号必须以正确的顺序闭合。</span></span><br><span class="line"><span class="string">每个右括号都有一个对应的相同类型的左括号。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &amp; <span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    stack = []</span><br><span class="line">    mapping = &#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> mapping:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != mapping[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><h3 id="2025-2-28"><a href="#2025-2-28" class="headerlink" title="2025&#x2F;2&#x2F;28"></a>2025&#x2F;2&#x2F;28</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 编写一个Python程序，接受一个字符串作为输入，并输出该字符串中出现次数最多的字符及其出现次数。&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_str</span>():</span><br><span class="line">    n = <span class="built_in">input</span>(<span class="string">&quot;输入一个字符串: &quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;空字符串&quot;</span></span><br><span class="line">    count_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> n:</span><br><span class="line">        count_dict[char] = count_dict.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    max_char = <span class="built_in">max</span>(count_dict, key=<span class="keyword">lambda</span> k: count_dict[k])</span><br><span class="line">    <span class="keyword">return</span> max_char, count_dict[max_char]</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;实现一个Python函数，接受一个整数列表作为参数，返回列表中所有偶数的平方和。&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_even_square</span>(<span class="params">n</span>):</span><br><span class="line">    even_square_total = <span class="built_in">sum</span>([i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> n <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> even_square_total</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 编写一个Python程序，模拟一个简单的银行账户管理系统。要求实现账户的创建、存款、取款、查询余额等功能。&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, phone</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.gender = gender</span><br><span class="line">        <span class="variable language_">self</span>.phone = phone</span><br><span class="line">        <span class="variable language_">self</span>.balance = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="variable language_">self</span>.balance += amount</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="keyword">if</span> amount &gt; <span class="variable language_">self</span>.balance:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;余额不足&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.balance -= amount</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_balance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.balance</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 编写一个Python程序，生成斐波那契数列的前N项，其中N由用户输入。&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    fib_sequence = []</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        fib_sequence.append(a)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fib_sequence</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;实现一个Python函数，接受一个字典作为参数，返回字典中值最大的键。&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_dict_key</span>(<span class="params">d</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(d, key=<span class="keyword">lambda</span> k: d[k])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;实现一个Python函数，接受两个字符串作为参数，返回这两个字符串的最长公共子串。&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">longest_common_substring</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    matrix = [[<span class="number">0</span>]*(<span class="built_in">len</span>(s2)+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)+<span class="number">1</span>)]</span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    end_pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s1)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s2)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>]:</span><br><span class="line">                matrix[i][j] = matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] &gt; max_len:</span><br><span class="line">                    max_len = matrix[i][j]</span><br><span class="line">                    end_pos = i</span><br><span class="line">    <span class="keyword">return</span> s1[end_pos-max_len:end_pos]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;实现一个Python函数，接受一个列表作为参数，返回列表中所有元素的排列组合。&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">all_permutations</span>(<span class="params">lst</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(permutations(lst))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="built_in">print</span>(all_permutations([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))  <span class="comment"># 输出所有排列</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="《数据结构与算法-python语言实现》练习题"><a href="#《数据结构与算法-python语言实现》练习题" class="headerlink" title="《数据结构与算法 python语言实现》练习题"></a>《数据结构与算法 python语言实现》练习题</h2><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个python函数is_multiple(n, m),用来接收两个整数值n和m,如果n是m的倍数，即存在整数i使得n = mi,那么函数返回True,否则返回False.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_multiple</span>(<span class="params">n, m</span>):</span><br><span class="line">    <span class="keyword">if</span> n % m == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># AI优化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_multiple</span>(<span class="params">n, m</span>):</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;The divisor &#x27;m&#x27; cannot be zero.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> n % m == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个Python函数is_even(k),用来接收一个整数K，如果k是偶数返回True，否则返回False。但是，函数不能使用乘法、除法或者取余操作。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">k</span>):</span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, k + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        a.append(i)</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">不需要创建列表a，可以通过位运算或减法来判断奇偶性。</span><br><span class="line">使用位运算k &amp; <span class="number">1</span>可以高效判断是否为偶数（偶数的最低位为<span class="number">0</span>）。</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AI优化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">return</span> (k &amp; <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个python函数minmax(data)，用来在数的序列中找出最小数和最大数，并以一个长度为2的元组的形式返回。注意：不能通过内置函数min和max来实现。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minmax</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="built_in">sorted</span>(data, reverse=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> data[<span class="number">0</span>], data[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="built_in">sorted</span>(data)不会修改原列表，而是返回一个新的排序列表。因此，这里并没有真正排序data。</span><br><span class="line">直接遍历列表找到最小值和最大值，避免不必要的排序操作。</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AI优化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minmax</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;The input list cannot be empty.&quot;</span>)</span><br><span class="line">    min_val = max_val = data[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> data[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> num &lt; min_val:</span><br><span class="line">            min_val = num</span><br><span class="line">        <span class="keyword">if</span> num &gt; max_val:</span><br><span class="line">            max_val = num</span><br><span class="line">    <span class="keyword">return</span> min_val, max_val</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个python函数，用来接收正整数n，返回1~n的平方和。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_add</span>(<span class="params">n</span>):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        s += i ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">可以直接使用数学公式计算平方和：n * (n + <span class="number">1</span>) * (<span class="number">2</span> * n + <span class="number">1</span>) // <span class="number">6</span>。</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AI优化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_add</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n * (n + <span class="number">1</span>) * (<span class="number">2</span> * n + <span class="number">1</span>) // <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">基于Python的解析语法和内置函数sum，写一个单独的命令来计算上一题1~n的平方和。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">n_square_add = <span class="built_in">sum</span>([i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> n])</span><br><span class="line"><span class="built_in">print</span>(n_square_add)</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">列表解析可以用生成器表达式替代，节省内存。</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AI优化</span></span><br><span class="line">n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">n_square_add = <span class="built_in">sum</span>(i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> n)</span><br><span class="line"><span class="built_in">print</span>(n_square_add)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">编写一个python函数，用来接收正整数n,并返回1~n中所有奇数的平方和。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">odd_square_add</span>(<span class="params">n</span>):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        s += i ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># AI优化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">odd_square_add</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">基于Python的解析语法和内置函数sum，写一个单独的命令来计算上一题1~n中所有奇数的平方和。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">n_odd_square_add = <span class="built_in">sum</span>([i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>, <span class="number">2</span>)])</span><br><span class="line"><span class="built_in">print</span>(n_odd_square_add)</span><br><span class="line"></span><br><span class="line"><span class="comment"># AI优化</span></span><br><span class="line">n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">n_odd_square_add = <span class="built_in">sum</span>(i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(n_odd_square_add)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">python允许负整数作为序列的索引值，如一个长度为n的字符串s，当索引值-n&lt;=k&lt;0时，所指的元素为s[k],那么求一个正整数索引值j&gt;=0,使得s[j]指向的也是相同的元素。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># k + j == 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AI优化</span></span><br><span class="line">j = <span class="built_in">len</span>(s) + k</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">要生成一个值为50, 60, 70, 80的排列，求range构造函数的参数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># range(50, 81, 10)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">要生成一个值为8, 6, 4, 2, 0, -2, -4, -6, -8的排列，求range构造函数的参数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># range(8, -9, -2)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">演示怎么使用python列表解析语法来产生列表[1, 2, 4, 8, 16, 32, 64, 128, 256]。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">two_square_sequ = [<span class="number">2</span> ** i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">python的random模块包括一个函数choice(data),可以从一个非空序列返回一个随机元素。</span></span><br><span class="line"><span class="string">Random模块还包括一个更基本的randrange函数，参数化类似于内置的range函数，可以在给定范围内返回一个随机数。只使用randrange函数，实现自己的choice函数。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">n = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">32</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    m = random.randrange(<span class="number">1</span>, <span class="number">33</span>)</span><br><span class="line">    <span class="keyword">if</span> m <span class="keyword">in</span> n:</span><br><span class="line">        <span class="built_in">print</span>(m)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">不需要无限循环，直接从n中随机选择一个元素即可。</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"># AI优化</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_choice</span>(<span class="params">data</span>):</span><br><span class="line">    index = random.randrange(<span class="built_in">len</span>(data))</span><br><span class="line">    <span class="keyword">return</span> data[index]</span><br><span class="line"></span><br><span class="line">n = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">32</span>]</span><br><span class="line"><span class="built_in">print</span>(custom_choice(n))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"># 给出3个生死攸关的软件应用程序的例子</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">1. 医疗设备控制系统（如呼吸机、心脏起搏器）</span><br><span class="line">作用：现代医疗设备（如呼吸机、心脏起搏器、放疗机）依赖软件精确控制治疗参数。例如：</span><br><span class="line">呼吸机：调节氧气输送量和呼吸频率，维持危重患者的生命。</span><br><span class="line">Therac-25 放疗机（历史案例）：1980年代因软件并发编程错误，导致多起患者因过量辐射死亡。</span><br><span class="line">风险：软件故障可能导致设备失控，例如呼吸机停止工作或放疗剂量超标，直接危及患者生命。</span><br><span class="line">2. 航空飞行控制系统（如飞机自动驾驶系统）</span><br><span class="line">作用：现代客机的飞行控制系统（如自动驾驶、失速保护系统）依赖软件处理传感器数据并调整飞行姿态。</span><br><span class="line">波音 737 MAX MCAS 系统：2018-2019年因软件错误（依赖单一传感器数据）导致两起空难，共346人死亡。</span><br><span class="line">空客 A380 飞控系统：软件需实时协调数百万行代码，确保飞行安全。</span><br><span class="line">风险：软件逻辑错误或传感器数据处理失误可能导致飞机失控或坠毁。</span><br><span class="line">3. 核电站安全监控系统</span><br><span class="line">作用：核电站使用软件监控反应堆温度、压力、辐射水平，并在异常时触发紧急停堆或冷却措施。</span><br><span class="line">福岛核事故（2011年）：虽主要由硬件（海堤）和供电故障引发，但安全系统的软件响应速度直接影响事故严重性。</span><br><span class="line">现代数字化控制系统：需实时处理数据并执行安全协议，防止堆芯熔毁或辐射泄漏。</span><br><span class="line">风险：软件延迟或逻辑错误可能导致无法及时阻止灾难性后果。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 给出一个软件应用程序的例子，其中适应性意味着产品销售和破产的生命周期间的不同。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">案例：桌面出版软件（DTP）领域的生死竞争</span><br><span class="line">QuarkXPress vs Adobe InDesign</span><br><span class="line">背景：20世纪90年代，QuarkXPress 是桌面出版行业的绝对霸主，市场份额超过90%，广泛应用于杂志、报纸和印刷品设计。其软件功能强大，但商业模式僵化（高单价买断制），且用户体验封闭。</span><br><span class="line"></span><br><span class="line">适应性差异如何决定生死</span><br><span class="line">1. Adobe InDesign的适应性策略</span><br><span class="line">技术适配：</span><br><span class="line">Adobe于1999年推出InDesign，初期功能不如QuarkXPress，但通过快速迭代整合自家Photoshop、Illustrator的协同生态，吸引设计师。</span><br><span class="line">2000年代初期，主动适配Mac OS X和Unicode（支持多语言），而QuarkXPress因兼容性延迟失去用户。</span><br><span class="line">商业模式转型：</span><br><span class="line">2013年推出Adobe Creative Cloud订阅服务，降低用户初始成本，并提供持续更新。</span><br><span class="line">通过云端协作（如Adobe Stock、Libraries）适应远程办公趋势。</span><br><span class="line">2. QuarkXPress的失败</span><br><span class="line">技术停滞：</span><br><span class="line">长期忽视用户对跨平台协作、XML数据整合的需求，更新缓慢。</span><br><span class="line">2004年推出的QuarkXPress 7因兼容性问题遭用户抵制。</span><br><span class="line">商业模式固化：</span><br><span class="line">坚持高价买断制（单套软件超$1000），拒绝订阅模式，中小企业转向Adobe。</span><br><span class="line">未建立生态，无法对抗Adobe的「全家桶」优势。</span><br><span class="line">结果：适应性决定企业生死</span><br><span class="line">Adobe：凭借持续适应市场需求，InDesign在2010年后市场份额反超，Quark公司收入暴跌，裁员收缩，濒临破产边缘。</span><br><span class="line">Quark：从行业巨头沦为小众工具，2020年其母公司被迫出售资产，退出主流市场。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 描述文本编辑器GUI的组件和它的封装的方法</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">文本编辑器 GUI 的典型组件与封装方法</span><br><span class="line">文本编辑器的 GUI 设计需兼顾功能性与代码可维护性。以下是核心组件及其面向对象封装策略（以跨平台框架如 Qt 或 Java Swing 为例）：</span><br><span class="line"></span><br><span class="line">1. 核心组件分解</span><br><span class="line">1.1 顶层容器（MainWindow）</span><br><span class="line">功能：窗口框架，包含菜单栏、工具栏、编辑区、状态栏等子组件。</span><br><span class="line">封装方法：</span><br><span class="line">Python</span><br><span class="line">class MainWindow(QMainWindow):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.init_ui()</span><br><span class="line">    </span><br><span class="line">    def init_ui(self):</span><br><span class="line">        self.setWindowTitle(&quot;Text Editor&quot;)</span><br><span class="line">        self._create_menu_bar()  # 封装菜单栏逻辑</span><br><span class="line">        self._create_tool_bar()  # 封装工具栏逻辑</span><br><span class="line">        self._create_editor()    # 封装文本编辑区</span><br><span class="line">        self._create_status_bar()# 封装状态栏</span><br><span class="line">关键点：将不同区域的初始化逻辑拆分为独立方法，避免 MainWindow 类臃肿。</span><br><span class="line">1.2 菜单栏（MenuBar）</span><br><span class="line">功能：提供文件操作（新建、打开、保存）、编辑操作（撤销、重做）、格式设置等功能入口。</span><br><span class="line">封装方法：</span><br><span class="line">Python</span><br><span class="line">class MenuBar(QMenuBar):</span><br><span class="line">    def __init__(self, parent=None):</span><br><span class="line">        super().__init__(parent)</span><br><span class="line">        self._create_file_menu()</span><br><span class="line">        self._create_edit_menu()</span><br><span class="line">    </span><br><span class="line">    def _create_file_menu(self):</span><br><span class="line">        file_menu = self.addMenu(&quot;文件&quot;)</span><br><span class="line">        new_action = QAction(&quot;新建&quot;, self)</span><br><span class="line">        new_action.triggered.connect(self._on_new)  # 绑定事件</span><br><span class="line">        file_menu.addAction(new_action)</span><br><span class="line">    </span><br><span class="line">    def _on_new(self):</span><br><span class="line">        # 委托给主窗口或控制器处理业务逻辑</span><br><span class="line">        self.parent().handle_new_file()  </span><br><span class="line">关键点：</span><br><span class="line">菜单项操作通过信号（如 triggered）与业务逻辑解耦。</span><br><span class="line">禁止在 MenuBar 中直接操作文本内容，通过接口调用主窗口或控制器。</span><br><span class="line">1.3 文本编辑区（TextEditorWidget）</span><br><span class="line">功能：文本输入、语法高亮、行号显示、滚动支持。</span><br><span class="line">封装方法（继承框架组件 + 扩展功能）：</span><br><span class="line">Python</span><br><span class="line">class TextEditorWidget(QPlainTextEdit):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self._init_editor_ui()</span><br><span class="line">    </span><br><span class="line">    def _init_editor_ui(self):</span><br><span class="line">        self.setLineWrapMode(QPlainTextEdit.NoWrap)  # 禁用自动换行</span><br><span class="line">        self.highlighter = SyntaxHighlighter(self.document())  # 语法高亮组件</span><br><span class="line">        self.line_number_area = LineNumberArea(self)  # 行号区域（自定义绘制）</span><br><span class="line">    </span><br><span class="line">    def keyPressEvent(self, event):</span><br><span class="line">        if event.key() == Qt.Key_Tab:</span><br><span class="line">            self.insertPlainText(&quot;    &quot;)  # 自定义 Tab 行为</span><br><span class="line">        else:</span><br><span class="line">            super().keyPressEvent(event)</span><br><span class="line">关键点：</span><br><span class="line">通过继承 QPlainTextEdit 复用基础功能，重写事件方法（如 keyPressEvent）实现定制行为。</span><br><span class="line">将语法高亮、行号等子功能拆分为独立类（如 SyntaxHighlighter），通过组合模式注入。</span><br><span class="line">1.4 状态栏（StatusBar）</span><br><span class="line">功能：显示光标位置、文件编码、行/列统计等信息。</span><br><span class="line">封装方法（观察者模式）：</span><br><span class="line">Python</span><br><span class="line">class EditorStatusBar(QStatusBar):</span><br><span class="line">    def __init__(self, editor):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.editor = editor</span><br><span class="line">        self._position_label = QLabel()</span><br><span class="line">        self.addWidget(self._position_label)</span><br><span class="line">        # 监听编辑器光标变化</span><br><span class="line">        editor.cursorPositionChanged.connect(self._update_position)</span><br><span class="line">    </span><br><span class="line">    def _update_position(self):</span><br><span class="line">        line = self.editor.textCursor().blockNumber() + 1</span><br><span class="line">        column = self.editor.textCursor().columnNumber() + 1</span><br><span class="line">        self._position_label.setText(f&quot;行: &#123;line&#125;, 列: &#123;column&#125;&quot;)</span><br><span class="line">关键点：通过事件监听（如 cursorPositionChanged）实现数据同步，状态栏不主动轮询编辑器状态。</span><br><span class="line">2. 封装原则与设计模式</span><br><span class="line">单一职责原则：每个类仅处理单一功能（如 MenuBar 只管理菜单项，不涉及文件读写逻辑）。</span><br><span class="line">观察者模式：状态栏监听编辑器事件，而非直接访问其内部状态。</span><br><span class="line">组合模式：将行号区域、语法高亮器等作为子组件注入编辑器。</span><br><span class="line">MVC 分离：</span><br><span class="line">Model：文本内容、用户配置（独立于 GUI 的纯数据类）。</span><br><span class="line">View：MainWindow 及其子组件，仅负责渲染和输入事件。</span><br><span class="line">Controller：处理业务逻辑（如文件保存、编辑操作），通过接口与 View 交互。</span><br><span class="line">3. 进阶封装策略</span><br><span class="line">插件系统：</span><br><span class="line">Python</span><br><span class="line">class PluginInterface(ABC):</span><br><span class="line">    @abstractmethod</span><br><span class="line">    def install(self, editor: TextEditorWidget):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class SpellCheckPlugin(PluginInterface):</span><br><span class="line">    def install(self, editor):</span><br><span class="line">        editor.installEventFilter(SpellCheckFilter())</span><br><span class="line">通过接口定义插件规范，支持动态加载功能模块。</span><br><span class="line">主题引擎：</span><br><span class="line">Python</span><br><span class="line">class ThemeManager:</span><br><span class="line">    def apply_theme(self, theme: str):</span><br><span class="line">        with open(f&quot;themes/&#123;theme&#125;.json&quot;) as f:</span><br><span class="line">            colors = json.load(f)</span><br><span class="line">            QApplication.setPalette(colors[&quot;palette&quot;])</span><br><span class="line">将样式配置外部化（JSON/CSS），实现界面换肤。</span><br><span class="line">总结</span><br><span class="line">文本编辑器的 GUI 封装需遵循 高内聚、低耦合 原则，通过面向对象设计模式将组件模块化。例如：</span><br><span class="line"></span><br><span class="line">使用继承复用框架控件功能（如 QPlainTextEdit）。</span><br><span class="line">通过组合模式集成子功能（行号、高亮）。</span><br><span class="line">借助观察者模式实现组件间通信。</span><br><span class="line">这种设计使得代码易于扩展（如新增插件）和维护（修改某一组件不影响其他模块）。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 编写一个类Flower。该类有str、int、float类型的三种实例变量，分别代表花的名字、花瓣的数量和价格。该类必须含有一个构造函数，该构造函数给每个变量初始化一个合适的值。该类应包含设置和检索每种类型值的方法。</span><br><span class="line">class Flower:</span><br><span class="line">    def __init__(self, name: str = &quot;&quot;, petals: int = 0, price: float = 0.0):</span><br><span class="line">        &quot;&quot;&quot;构造函数初始化花的属性，支持类型验证和自动转换&quot;&quot;&quot;</span><br><span class="line">        self.set_name(name)</span><br><span class="line">        self.set_petals(petals)</span><br><span class="line">        self.set_price(price)</span><br><span class="line"></span><br><span class="line">    # 名称属性方法组</span><br><span class="line">    def set_name(self, name: str) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;设置花名，强制字符串类型&quot;&quot;&quot;</span><br><span class="line">        if not isinstance(name, str):</span><br><span class="line">            raise TypeError(&quot;Name must be a string.&quot;)</span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line">    def get_name(self) -&gt; str:</span><br><span class="line">        &quot;&quot;&quot;返回花名&quot;&quot;&quot;</span><br><span class="line">        return self._name</span><br><span class="line"></span><br><span class="line">    # 花瓣属性方法组</span><br><span class="line">    def set_petals(self, petals: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;设置花瓣数，强制整数类型&quot;&quot;&quot;</span><br><span class="line">        if not isinstance(petals, int):</span><br><span class="line">            raise TypeError(&quot;Petals must be an integer.&quot;)</span><br><span class="line">        self._petals = petals</span><br><span class="line"></span><br><span class="line">    def get_petals(self) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;返回花瓣数&quot;&quot;&quot;</span><br><span class="line">        return self._petals</span><br><span class="line"></span><br><span class="line">    # 价格属性方法组</span><br><span class="line">    def set_price(self, price: float) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;设置价格，支持整数/浮点数输入，自动转为浮点&quot;&quot;&quot;</span><br><span class="line">        if isinstance(price, (int, float)):</span><br><span class="line">            self._price = float(price)</span><br><span class="line">        else:</span><br><span class="line">            raise TypeError(&quot;Price must be a numeric type.&quot;)</span><br><span class="line"></span><br><span class="line">    def get_price(self) -&gt; float:</span><br><span class="line">        &quot;&quot;&quot;返回价格&quot;&quot;&quot;</span><br><span class="line">        return self._price</span><br><span class="line"></span><br><span class="line">    # 可选：属性式访问（兼容传统getter/setter）</span><br><span class="line">    name = property(get_name, set_name)</span><br><span class="line">    petals = property(get_petals, set_petals)</span><br><span class="line">    price = property(get_price, set_price)</span><br><span class="line">    </span><br><span class="line"># 初始化实例</span><br><span class="line">rose = Flower(&quot;Rose&quot;, 12, 9.99)</span><br><span class="line"></span><br><span class="line"># 属性式访问</span><br><span class="line">print(f&quot;&#123;rose.name&#125; 有 &#123;rose.petals&#125; 瓣，售价 $&#123;rose.price:.2f&#125;&quot;)</span><br><span class="line"># 输出：Rose 有 12 瓣，售价 $9.99</span><br><span class="line"></span><br><span class="line"># 传统方法调用</span><br><span class="line">rose.set_petals(24)</span><br><span class="line">print(f&quot;升级版 &#123;rose.get_name()&#125; 有 &#123;rose.get_petals()&#125; 瓣&quot;)</span><br><span class="line"># 输出：升级版 Rose 有 24 瓣</span><br><span class="line"></span><br><span class="line"># 类型安全验证测试</span><br><span class="line">try:</span><br><span class="line">    rose.set_name(123)  # 传入非字符串名称</span><br><span class="line">except TypeError as e:</span><br><span class="line">    print(f&quot;错误捕获：&#123;e&#125;&quot;)</span><br><span class="line"># 输出：错误捕获：Name must be a string.</span><br><span class="line"></span><br><span class="line"># AI优化</span><br><span class="line">class Flower:</span><br><span class="line">    def __init__(self, name: str = &quot;Unknown&quot;, petals: int = 0, price: float = 0.0):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        构造函数，通过属性设置器进行初始化验证</span><br><span class="line">        :param name: 花名，默认&quot;Unknown&quot;</span><br><span class="line">        :param petals: 花瓣数，默认0</span><br><span class="line">        :param price: 价格，默认0.0</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.petals = petals</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    # 名称属性</span><br><span class="line">    @property</span><br><span class="line">    def name(self) -&gt; str:</span><br><span class="line">        &quot;&quot;&quot;返回花名&quot;&quot;&quot;</span><br><span class="line">        return self._name</span><br><span class="line"></span><br><span class="line">    @name.setter</span><br><span class="line">    def name(self, value: str):</span><br><span class="line">        &quot;&quot;&quot;设置花名，强制字符串类型&quot;&quot;&quot;</span><br><span class="line">        if not isinstance(value, str):</span><br><span class="line">            raise TypeError(&quot;花名必须为字符串类型&quot;)</span><br><span class="line">        self._name = value</span><br><span class="line"></span><br><span class="line">    # 花瓣属性</span><br><span class="line">    @property</span><br><span class="line">    def petals(self) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;返回花瓣数量&quot;&quot;&quot;</span><br><span class="line">        return self._petals</span><br><span class="line"></span><br><span class="line">    @petals.setter</span><br><span class="line">    def petals(self, value: int):</span><br><span class="line">        &quot;&quot;&quot;设置花瓣数，必须为非负整数&quot;&quot;&quot;</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise TypeError(&quot;花瓣数量必须为整数&quot;)</span><br><span class="line">        if value &lt; 0:</span><br><span class="line">            raise ValueError(&quot;花瓣数量不能为负数&quot;)</span><br><span class="line">        self._petals = value</span><br><span class="line"></span><br><span class="line">    # 价格属性</span><br><span class="line">    @property</span><br><span class="line">    def price(self) -&gt; float:</span><br><span class="line">        &quot;&quot;&quot;返回价格（保留两位小数）&quot;&quot;&quot;</span><br><span class="line">        return self._price</span><br><span class="line"></span><br><span class="line">    @price.setter</span><br><span class="line">    def price(self, value: float):</span><br><span class="line">        &quot;&quot;&quot;设置价格，支持数值类型，自动保留两位小数&quot;&quot;&quot;</span><br><span class="line">        if not isinstance(value, (int, float)):</span><br><span class="line">            raise TypeError(&quot;价格必须为数字类型&quot;)</span><br><span class="line">        if value &lt; 0:</span><br><span class="line">            raise ValueError(&quot;价格不能为负数&quot;)</span><br><span class="line">        # 处理浮点精度，四舍五入到分</span><br><span class="line">        self._price = round(float(value), 2)</span><br><span class="line"></span><br><span class="line">    def __str__(self) -&gt; str:</span><br><span class="line">        &quot;&quot;&quot;中文格式化输出&quot;&quot;&quot;</span><br><span class="line">        return f&quot;花卉详情：名称=&#123;self.name&#125;，花瓣数=&#123;self.petals&#125;，价格=￥&#123;self.price:.2f&#125;&quot;</span><br><span class="line"></span><br><span class="line">    def __repr__(self) -&gt; str:</span><br><span class="line">        &quot;&quot;&quot;开发调试用表示&quot;&quot;&quot;</span><br><span class="line">        return f&quot;&lt;Flower &#123;self.name&#125; (petals=&#123;self.petals&#125;, price=&#123;self.price&#125;)&gt;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 正常使用测试</span><br><span class="line">    lily = Flower(&quot;百合&quot;, 6, 15.99)</span><br><span class="line">    print(lily)  # 花卉详情：名称=百合，花瓣数=6，价格=￥15.99</span><br><span class="line"></span><br><span class="line">    # 边界值测试</span><br><span class="line">    default_flower = Flower()</span><br><span class="line">    print(default_flower)  # 花卉详情：名称=Unknown，花瓣数=0，价格=￥0.00</span><br><span class="line"></span><br><span class="line">    # 价格精度测试</span><br><span class="line">    rose = Flower(&quot;玫瑰&quot;, 12, 9.999)</span><br><span class="line">    print(rose)  # 自动四舍五入 =&gt; 花卉详情：名称=玫瑰，花瓣数=12，价格=￥10.00</span><br><span class="line"></span><br><span class="line">    # 异常处理测试</span><br><span class="line">    try:</span><br><span class="line">        Flower(123, 5, 9.99)  # 错误名称类型</span><br><span class="line">    except TypeError as e:</span><br><span class="line">        print(f&quot;异常捕获：&#123;e&#125;&quot;)  # 花名必须为字符串类型</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        Flower(&quot;雏菊&quot;, -3, 5.0)  # 负数花瓣</span><br><span class="line">    except ValueError as e:</span><br><span class="line">        print(f&quot;异常捕获：&#123;e&#125;&quot;)  # 花瓣数量不能为负数</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        Flower(&quot;郁金香&quot;, 6, &quot;free&quot;)  # 非数字价格</span><br><span class="line">    except TypeError as e:</span><br><span class="line">        print(f&quot;异常捕获：&#123;e&#125;&quot;)  # 价格必须为数字类型</span><br><span class="line"></span><br><span class="line">    # 动态修改测试</span><br><span class="line">    lily.petals = 8</span><br><span class="line">    lily.price = 19.999  # 自动四舍五入为20.00</span><br><span class="line">    print(f&quot;升级版：&#123;lily.name&#125; 有 &#123;lily.petals&#125; 片花瓣，售价 &#123;lily.price&#125; 元&quot;)</span><br><span class="line">    # 升级版：百合 有 8 片花瓣，售价 20.0 元</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法和数据结构的学习"><a href="#算法和数据结构的学习" class="headerlink" title="算法和数据结构的学习"></a>算法和数据结构的学习</h2><h3 id="前缀和算法思想"><a href="#前缀和算法思想" class="headerlink" title="前缀和算法思想"></a>前缀和算法思想</h3><h4 id="核心方法："><a href="#核心方法：" class="headerlink" title="核心方法："></a>核心方法：</h4><ol><li>预处理</li><li>区间和计算</li></ol><h3 id="递归和迭代-1"><a href="#递归和迭代-1" class="headerlink" title="递归和迭代"></a>递归和迭代</h3><h4 id="核心概念对比"><a href="#核心概念对比" class="headerlink" title="核心概念对比"></a>核心概念对比</h4><h5 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h5><ul><li><strong>本质</strong>：通过函数自我调用实现问题分解</li><li><strong>数学模型</strong>：符合分治法（Divide and Conquer）思想</li><li><strong>关键要素</strong>：<ul><li>基线条件（Base Case）：终止递归的明确条件</li><li>递归条件（Recursive Case）：将问题分解为更小规模的子问题</li></ul></li><li><strong>典型应用</strong>：树遍历、分形计算、回溯算法</li></ul><h5 id="迭代（Iteration）"><a href="#迭代（Iteration）" class="headerlink" title="迭代（Iteration）"></a>迭代（Iteration）</h5><ul><li><strong>本质</strong>：通过循环结构重复执行代码块</li><li><strong>数学模型</strong>：基于数学归纳法的逐步推进</li><li><strong>关键要素</strong>：<ul><li>循环条件（Termination Condition）</li><li>状态变量（State Variable）</li><li>迭代步长（Step Size）</li></ul></li><li><strong>典型应用</strong>：数组遍历、数值计算、状态机实现</li></ul><h4 id="执行机制对比"><a href="#执行机制对比" class="headerlink" title="执行机制对比"></a>执行机制对比</h4><table><thead><tr><th>维度</th><th>递归</th><th>迭代</th></tr></thead><tbody><tr><td><strong>内存占用</strong></td><td>调用栈存储上下文（O(n)）</td><td>固定内存空间（O(1)）</td></tr><tr><td><strong>时间效率</strong></td><td>函数调用开销较大</td><td>循环控制开销较小</td></tr><tr><td><strong>可读性</strong></td><td>逻辑简洁但需抽象思维</td><td>步骤明确但可能冗长</td></tr><tr><td><strong>调试难度</strong></td><td>栈跟踪复杂</td><td>单步调试直观</td></tr><tr><td><strong>适用场景</strong></td><td>树状&#x2F;分治问题</td><td>线性&#x2F;重复计算</td></tr></tbody></table><h4 id="经典案例对比分析"><a href="#经典案例对比分析" class="headerlink" title="经典案例对比分析"></a>经典案例对比分析</h4><h5 id="阶乘计算"><a href="#阶乘计算" class="headerlink" title="阶乘计算"></a>阶乘计算</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial_r</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">else</span> n * factorial_r(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorial_i</span>(<span class="params">n</span>):</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="数组-array"><a href="#数组-array" class="headerlink" title="数组(array)"></a>数组(array)</h3><h4 id="静态数组-vs-动态数组"><a href="#静态数组-vs-动态数组" class="headerlink" title="静态数组 vs 动态数组"></a>静态数组 vs 动态数组</h4><ol><li><strong>静态数组</strong></li></ol><ul><li><p><strong>定义</strong>： 编译时确定大小，内存分配在栈区或全局区的数组</p></li><li><p><strong>特点</strong>：</p><ul><li><strong>不可变容量</strong>： 初始化后大小固定（如C语言中的<strong>int arr[10]</strong>）</li><li><strong>内存分配</strong>： 在栈内存中直接分配（访问速度快）</li><li><strong>类型约束</strong>： 所有元素必须为相同类型（强类型语言）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> static_arr[<span class="number">5</span>];  <span class="comment">// 静态数组声明</span></span><br><span class="line">static_arr[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">// static_arr[5] = 20; // 越界访问，导致未定义行为</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>动态数组</strong></li></ol><ul><li><strong>定义</strong>： 运行时确定大小，内存分配在堆区的数组</li><li><strong>特点</strong>：<ul><li><strong>可变容量</strong>： 通过自动扩容机制动态调整大小（如Python列表）</li><li><strong>内存分配</strong>： 通过指针管理堆内存（需要手动释放或依赖GC）</li><li><strong>类型灵活</strong>： 在弱类型语言中可存储不同类型（如Python列表）</li></ul></li><li><strong>扩容原理</strong>：<ol><li>初始分配固定容量（如Python列表初始分配空间为<strong>大于元素数量的最小2^n</strong>)</li><li>当元素数量达到当前容量时：<ul><li>新容量 &#x3D; 旧容量 * <strong>扩容因子</strong>（通常为1.5~2倍）</li><li>申请新内存空间—-&gt;复制旧数据—-&gt;释放旧内存</li></ul></li><li><strong>均摊时间复杂度</strong>：单次插入操作平均O(1)</li></ol></li></ul><h4 id="动态数组的实质"><a href="#动态数组的实质" class="headerlink" title="动态数组的实质"></a>动态数组的实质</h4><ol><li><p><strong>与静态数组的关系</strong></p><ul><li><p><strong>底层实现</strong>: 动态数组本质是静态数组的封装</p></li><li><p><strong>核心差异</strong>：</p><table><thead><tr><th>特性</th><th>静态数组</th><th>动态数组</th></tr></thead><tbody><tr><td>内存分配位置</td><td>栈内存</td><td>堆内存</td></tr><tr><td>容量可变性</td><td>固定大小</td><td>自动扩容</td></tr><tr><td>访问速度</td><td>更快（无额外指针跳转）</td><td>稍慢（需指针间接访问）</td></tr></tbody></table></li></ul></li><li><p><strong>Python列表的真相</strong></p><ul><li><p><strong>看似矛盾的现象</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="string">&quot;text&quot;</span>, <span class="number">3.14</span>]  <span class="comment"># 存储不同类型元素</span></span><br></pre></td></tr></table></figure></li><li><p><strong>实现机制</strong>：</p><ul><li>动态数组内部存储的是<strong>对象指针</strong>（所有元素均为<strong>PyObject</strong>类型）</li><li>物理内存连续存储指针，而非实际数据</li><li>实际数据分散在堆内存中，通过指针引用</li></ul></li></ul></li></ol><h4 id="数据类型约束本质"><a href="#数据类型约束本质" class="headerlink" title="数据类型约束本质"></a>数据类型约束本质</h4><ol><li><p><strong>严格类型语言（C&#x2F;Java</strong>）</p><ul><li><p><strong>内存结构</strong>：直接存储元素值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]: 	<span class="comment">//内存中连续存储3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>类型限制</strong>：</p><ul><li>所有元素必须为声明类型</li><li>访问时直接按类型长度计算偏移量</li></ul></li></ul></li><li><p><strong>弱类型语言（Python&#x2F;JavaScript）</strong></p><ul><li><p><strong>内存结构</strong>： 存储指向对象的指针</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python列表内存布局：</span><br><span class="line">[指针0] --&gt; 整数对象</span><br><span class="line">[指针1] --&gt; 字符串对象</span><br><span class="line">[指针2] --&gt; 浮点数对象</span><br></pre></td></tr></table></figure></li><li><p><strong>特殊性质</strong>：</p><ul><li><strong>逻辑上</strong>可存储不同类型</li><li><strong>物理上</strong>指针数组仍然是连续内存空间</li></ul></li></ul></li></ol><h4 id="关键概念对比表"><a href="#关键概念对比表" class="headerlink" title="关键概念对比表"></a>关键概念对比表</h4><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94%E8%A1%A8.png" alt="image-20250301101702153"></p><h4 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h4><p><strong>误区1： 动态数组直接存储数据</strong></p><ul><li><strong>真相</strong>：动态数组存储的是指针（Python等语言），实际数据分散存储</li></ul><p><strong>误区2： 所有语言的数组都允许不同类型元素</strong></p><ul><li><strong>正解</strong>： 仅在弱类型语言中成立， 强类型语言严格限制元素类型</li></ul><p><strong>误区3： 动态数组扩容是实时完成的</strong></p><ul><li><strong>实际策略</strong>： 采用<strong>预分配机制</strong>（超额分配）如Python List</li></ul><h3 id="链表（Linked-List"><a href="#链表（Linked-List" class="headerlink" title="链表（Linked List)"></a>链表（Linked List)</h3><h4 id="什么是链表（Linked-List）"><a href="#什么是链表（Linked-List）" class="headerlink" title="什么是链表（Linked List）?"></a>什么是链表（Linked List）?</h4><p>定义： 链表是由一系列节点（Node）组成的线性数据结构，每个节点包含：</p><ol><li><strong>数据域</strong>： 存储实际数据</li><li><strong>指针域</strong>： 存储下一个节点的内存地址</li></ol><p>核心特征：</p><ul><li><strong>非连续存储</strong>： 节点在内存中分散存放</li><li><strong>动态扩展</strong>： 不需要预先分配固定空间</li><li><strong>单向&#x2F;双向</strong>： 单链表每个节点只有一个指针，双链表有两个指针（前驱和后继）</li></ul><h4 id="链表的作用"><a href="#链表的作用" class="headerlink" title="链表的作用"></a>链表的作用</h4><ol><li><strong>动态内存管理</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统数组需要预先分配连续内存</span></span><br><span class="line">arr = [<span class="literal">None</span>] * <span class="number">10</span> 			<span class="comment"># 强制占用10个位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表按需动态分配内存</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span>	<span class="comment"># 随时可扩展新节点</span></span><br></pre></td></tr></table></figure><ol start="2"><li>高效插入&#x2F;删除</li></ol><table><thead><tr><th>操作</th><th>数组时间复杂度</th><th>链表时间复杂度</th></tr></thead><tbody><tr><td>头部插入</td><td>O(n)</td><td>O(1)</td></tr><tr><td>中间插入</td><td>O(n)</td><td>O(1) (已知位置)</td></tr><tr><td>尾部插入</td><td>O(1)</td><td>O(n)</td></tr></tbody></table><h4 id="链表存在的意义"><a href="#链表存在的意义" class="headerlink" title="链表存在的意义"></a>链表存在的意义</h4><ol><li><strong>解决数组的痛点</strong><ul><li><strong>内存碎片利用</strong>： 允许使用分散的内存块</li><li><strong>避免整体复制</strong>： 插入元素无需移动其他元素</li><li><strong>无限扩展性（理论上）</strong>： 无固定容量限制</li></ul></li><li><strong>特殊场景优势</strong><ul><li><strong>实现栈&#x2F;队列</strong>： 适合频繁的头部操作</li><li><strong>内存敏感场景</strong>： 嵌入式系统中管理动态内存</li><li><strong>内核开发</strong>：Linux内核的任务调度使用链表</li></ul></li></ol><h4 id="哨兵节点技巧（Dummy-Node）"><a href="#哨兵节点技巧（Dummy-Node）" class="headerlink" title="哨兵节点技巧（Dummy Node）"></a>哨兵节点技巧（Dummy Node）</h4><ol><li><p><strong>作用</strong></p><ul><li>消除头节点的特殊性处理</li><li>统一所有节点的操作逻辑</li></ul></li><li><p><strong>使用示例（单链表删除节点）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delete_node</span>(<span class="params">head, val</span>):</span><br><span class="line">    dummy = Node(<span class="number">0</span>)  <span class="comment"># 哨兵节点</span></span><br><span class="line">    dummy.<span class="built_in">next</span> = head</span><br><span class="line">    curr = dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> curr.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> curr.<span class="built_in">next</span>.val == val:</span><br><span class="line">            curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span>  <span class="comment"># 返回新头节点</span></span><br></pre></td></tr></table></figure></li><li><p><strong>哨兵节点优势对比</strong></p><table><thead><tr><th>场景</th><th>无哨兵代码行数</th><th>有哨兵代码行数</th></tr></thead><tbody><tr><td>空链表</td><td>需要特殊处理</td><td>无需处理</td></tr><tr><td>删除头节点</td><td>单独逻辑判断</td><td>统一处理</td></tr></tbody></table></li></ol><h4 id="链表节点的本质"><a href="#链表节点的本质" class="headerlink" title="链表节点的本质"></a>链表节点的本质</h4><ol><li><strong>节点结构示例</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = x	<span class="comment"># 数据域</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 指针域（单链表）</span></span><br><span class="line">        <span class="comment"># self.prev = None	# 双向链表需要前驱指针</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>节点连接示意图</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">节点A             节点B             节点C</span><br><span class="line">+-------+------+  +-------+------+  +-------+------+</span><br><span class="line">| val=5 | next |→ | val=3 | next |→ | val=7 | next |→ None</span><br><span class="line">+-------+------+  +-------+------+  +-------+------+</span><br></pre></td></tr></table></figure></li></ol><h4 id="指针在链表中的本质"><a href="#指针在链表中的本质" class="headerlink" title="指针在链表中的本质"></a>指针在链表中的本质</h4><ol><li><p><strong>指针的物理含义</strong></p><ul><li>内存地址标识符： 每个节点存放的位置标记</li><li>引用传递工具： 通过地址找到下一个节点</li></ul></li><li><p><strong>Python中的实现特性</strong></p><p>虽然Python没有显式指针，但通过<strong>对象引用</strong>实现相同的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = x	<span class="comment"># 数据域</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 指针域（单链表）</span></span><br><span class="line">        <span class="comment"># self.prev = None	# 双向链表需要前驱指针</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建两个节点</span></span><br><span class="line">node1 = ListNode(<span class="number">10</span>)</span><br><span class="line">node2 = ListNode(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过引用建立连接</span></span><br><span class="line">node1.<span class="built_in">next</span> = node2  <span class="comment"># node1的next指针指向node2</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h4><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8.png" alt="image-20250302132439368"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">是否需要频繁中间插入/删除？</span><br><span class="line">├── 是 → 链表</span><br><span class="line">└── 否 → </span><br><span class="line">    ├── 是否需要高速随机访问？</span><br><span class="line">    │   ├── 是 → 数组</span><br><span class="line">    │   └── 否 → </span><br><span class="line">    │       ├── 内存是否敏感？</span><br><span class="line">    │       │   ├── 是 → 数组</span><br><span class="line">    │       │   └── 否 → 链表</span><br><span class="line">    └── 是否需要保证内存连续性？</span><br><span class="line">        ├── 是 → 数组</span><br><span class="line">        └── 否 → 链表</span><br></pre></td></tr></table></figure><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="image-20250302132534360"></p><h5 id="关键对比表"><a href="#关键对比表" class="headerlink" title="关键对比表"></a>关键对比表</h5><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%85%B3%E9%94%AE%E5%AF%B9%E6%AF%94%E8%A1%A8.png" alt="image-20250302130612635"></p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="栈与队列的本质定义"><a href="#栈与队列的本质定义" class="headerlink" title="栈与队列的本质定义"></a>栈与队列的本质定义</h4><ol><li><strong>栈（stack）</strong><ul><li><strong>结构特性</strong>: LIFO（Last In First On， 后进先出）</li><li><strong>核心操作</strong>:<ul><li><strong>push()</strong>: 元素入栈（时间复杂度O(1)）</li><li><strong>pop()</strong>: 弹出栈顶元素（O(1)）</li><li><strong>peek()</strong>: 查看栈顶元素（O(1)）</li></ul></li></ul></li><li><strong>队列（Queue）</strong><ul><li><strong>结构特性</strong>: FIFO（First In First Out， 先进先出）</li><li><strong>核心操作</strong>:<ul><li><strong>enqueue()</strong>: 元素入队尾（O(1)）</li><li><strong>dequeue()</strong>: 从队首出队（O(1)）</li><li><strong>front()</strong>: 查看队首元素（O(1)）</li></ul></li></ul></li></ol><h4 id="关键实现细节"><a href="#关键实现细节" class="headerlink" title="关键实现细节"></a>关键实现细节</h4><ol><li><p><strong>栈的实现选择</strong></p><table><thead><tr><th>实现方式</th><th>优点</th><th>缺点</th><th>典型场景</th></tr></thead><tbody><tr><td>数组</td><td>缓存友好，访问速度快</td><td>扩容成本高</td><td>明确最大深度的场景</td></tr><tr><td>链表</td><td>动态扩展无内存浪费</td><td>指针跳转增加缓存未命中</td><td>深度不可预知的场景</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于列表实现栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>._data = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>._data.append(val)  <span class="comment"># O(1)均摊时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._data:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;Pop from empty stack&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data.pop()</span><br></pre></td></tr></table></figure></li><li><p><strong>队列的实现陷阱</strong></p><ul><li><p><strong>假溢出问题</strong>: 数组实现的队列需要循环缓冲区</p></li><li><p><strong>线程安全</strong>: 多线程环境需使用双锁或原子操作</p></li><li><p><strong>优先队列</strong>：基于堆实现按优先级出队</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>):</span><br><span class="line">        <span class="variable language_">self</span>._data = [<span class="literal">None</span>] * (capacity + <span class="number">1</span>)  <span class="comment"># 多留一个空位判满</span></span><br><span class="line">        <span class="variable language_">self</span>._head = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>._tail = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">self</span>._tail + <span class="number">1</span>) % <span class="built_in">len</span>(<span class="variable language_">self</span>._data) == <span class="variable language_">self</span>._head:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Queue is full&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._data[<span class="variable language_">self</span>._tail] = val</span><br><span class="line">        <span class="variable language_">self</span>._tail = (<span class="variable language_">self</span>._tail + <span class="number">1</span>) % <span class="built_in">len</span>(<span class="variable language_">self</span>._data)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h4><ol><li><p><strong>栈的核心应用</strong></p><ul><li><strong>括号匹配</strong>（LeetCode 20）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    stack = []</span><br><span class="line">    mapping = &#123;<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> mapping:</span><br><span class="line">            top = stack.pop() <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> mapping[char] != top:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(char)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><ul><li><strong>函数调用栈</strong>: 程序执行时的上下文存储</li><li><strong>撤销操作</strong>： 操作历史栈</li></ul></li><li><p>队列的核心应用</p><ul><li><strong>BFS广度优先搜索</strong>（LeetCode 102二叉树层序遍历）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">level_order</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            level.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        res.append(level)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li><strong>消息队列</strong>： 系统间异步通信</li><li><strong>打印机任务调度</strong>： 按提交顺序处理</li></ul></li></ol><h4 id="选择决策树"><a href="#选择决策树" class="headerlink" title="选择决策树"></a>选择决策树</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">需要处理最近关联元素吗？</span><br><span class="line">├── 是 → 使用栈（如括号匹配、递归展开）</span><br><span class="line">└── 否 → </span><br><span class="line">    ├── 需要保持处理顺序吗？</span><br><span class="line">    │   ├── 是 → 使用队列（如任务调度、BFS）</span><br><span class="line">    │   └── 否 → </span><br><span class="line">    │       ├── 需要优先级处理吗？</span><br><span class="line">    │       │   ├── 是 → 优先队列（如Dijkstra算法）</span><br><span class="line">    │       │   └── 否 → 基本队列</span><br><span class="line">    └── 需要双向操作吗？</span><br><span class="line">        ├── 是 → 双端队列（如滑动窗口）</span><br><span class="line">        └── 否 → 基本队列</span><br></pre></td></tr></table></figure><h4 id="在数据结构体现中的地位"><a href="#在数据结构体现中的地位" class="headerlink" title="在数据结构体现中的地位"></a>在数据结构体现中的地位</h4><ol><li><p><strong>算法基础支撑</strong></p><ul><li><strong>递归的本质</strong>: 函数调用栈的隐式使用</li><li><strong>DFS vs BFS</strong>: 显式使用栈和队列</li><li><strong>语法解析</strong>: 编译器使用栈进行语法树构建</li></ul></li><li><p><strong>系统底层引用</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E5%BC%95%E7%94%A8.png" alt="image-20250303093153318"></p></li><li><p><strong>进阶算法基石</strong></p><ul><li><p><strong>单调栈</strong>: 解决Next Greater Element类问题 （LeetCode 496）</p></li><li><p><strong>优先队列</strong>: 合并K个有序链表 (LeetCode 23)</p></li><li><p><strong>双栈实现队列</strong> (LeetCode 232)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.in_stack = []</span><br><span class="line">        <span class="variable language_">self</span>.out_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="variable language_">self</span>.in_stack.append(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_transfer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.out_stack:</span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>.in_stack:</span><br><span class="line">                <span class="variable language_">self</span>.out_stack.append(<span class="variable language_">self</span>.in_stack.pop())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>._transfer()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.out_stack.pop()</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="常见误区警示"><a href="#常见误区警示" class="headerlink" title="常见误区警示"></a>常见误区警示</h4><ol><li><strong>栈溢出风险</strong>:<ul><li>递归深度过大导致栈溢出（Python默认递归深度约1000层）</li><li>解决方案： 改用迭代或者尾递归优化</li></ul></li><li><strong>队列假满判断</strong>：<ul><li>循环队列中<strong>head &#x3D;&#x3D; tail</strong>既可表示空也可以表示满</li><li>正确做法： 始终保留一个空位或使用计数器</li></ul></li><li><strong>时间复杂度误判</strong>：<ul><li>动态数组实现的栈： **push()**操作均摊O(1)但单词可能O(n)</li><li>链式队列的**dequeue()**需注意指针操作的顺序</li></ul></li></ol><h3 id="哈希表（Hash-Table）"><a href="#哈希表（Hash-Table）" class="headerlink" title="哈希表（Hash Table）"></a>哈希表（Hash Table）</h3><h4 id="哈希表（Hash-Table）的本质"><a href="#哈希表（Hash-Table）的本质" class="headerlink" title="哈希表（Hash Table）的本质"></a>哈希表（Hash Table）的本质</h4><p>哈希表是一种通过**键（Key）直接访问值（Value）**的数据结构，其核心设计包含两个关键组件：</p><ol><li><strong>哈希函数（HashFunction）</strong><ul><li>将任意大小的数据（Key）映射到固定范围的整数值（哈希值）</li><li>数学表达： hash(key) –&gt; integer</li></ul></li><li><strong>存储结构</strong><ul><li><strong>数组</strong>： 存储数据的核心容器</li><li><strong>冲突解决机制</strong>： 处理不同Key映射到同一数组索引的情况</li></ul></li></ol><h4 id="哈希函数的核心特征"><a href="#哈希函数的核心特征" class="headerlink" title="哈希函数的核心特征"></a>哈希函数的核心特征</h4><table><thead><tr><th>特征</th><th>说明</th><th>示例（Python内置哈希）</th></tr></thead><tbody><tr><td><strong>确定性</strong></td><td>相同Key始终得到相同哈希值</td><td>hash(“apple”)恒为固定值</td></tr><tr><td><strong>均匀性</strong></td><td>哈希值应均匀分布在值域范围内</td><td>好的哈希函数减少冲突概率</td></tr><tr><td><strong>高效性</strong></td><td>计算速度快（时间复杂度O(1)）</td><td>字符串哈希通常设计为线性时间</td></tr><tr><td><strong>抗碰撞性</strong></td><td>不同Key生成相同哈希值的概率低（密码学哈希要求更高）</td><td>MD5、SHA-1（但常规哈希表不要求密码学强度）</td></tr></tbody></table><h4 id="可哈希性（Hashability）判断"><a href="#可哈希性（Hashability）判断" class="headerlink" title="可哈希性（Hashability）判断"></a>可哈希性（Hashability）判断</h4><p>在python中，一个对象是否可哈希由以下特征决定:</p><ol><li><p><strong>可哈希对象的核心特征</strong></p><ul><li><strong>不可变性（Immutable）</strong>: 对象创建后无法修改内部状态</li><li><strong>实现__hash__()方法</strong>: 返回整型哈希值</li><li><strong>实现__eq__()方法</strong>: 用于比较相等性</li></ul></li><li><p>Python内置类型的可哈希性</p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/python%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%AF%E5%93%88%E5%B8%8C%E6%80%A7.png" alt="image-20250303104231624"></p></li><li><p>自定义类的可哈希性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">id</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">id</span> = <span class="built_in">id</span>  <span class="comment"># 若id不可变，可哈希</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(<span class="variable language_">self</span>.<span class="built_in">id</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.<span class="built_in">id</span> == other.<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时User实例可作为字典的键</span></span><br><span class="line">user_dict = &#123;User(<span class="number">1001</span>): <span class="string">&quot;Alice&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="哈希表的工作原理"><a href="#哈希表的工作原理" class="headerlink" title="哈希表的工作原理"></a>哈希表的工作原理</h4><ol><li><p>存储结构示意图</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">索引 | 存储内容（假设使用链地址法）</span><br><span class="line">-----|------------------------------</span><br><span class="line">0    | → (key1, val1) → (key4, val4)</span><br><span class="line">1    | → (key2, val2)</span><br><span class="line">2    | 空</span><br><span class="line">3    | → (key3, val3)</span><br></pre></td></tr></table></figure></li><li><p><strong>操作流程</strong></p><ul><li><strong>插入数据</strong>:<ol><li>计算机Key的哈希值<strong><code>h = hash(key)</code></strong></li><li>计算数组索引<strong><code>index = h % array_size</code></strong></li><li>处理冲突（如链地址法将节点挂到链表）</li></ol></li><li>查找数据:<ol><li>同样计算索引定位到桶（Bucket）</li><li>遍历桶内元素比较Key（需要<strong><code>__eq__</code></strong>方法）</li></ol></li></ul></li><li><p>冲突解决策略</p><table><thead><tr><th>策略</th><th>原理</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>链地址法</strong></td><td>每个桶用链表存储冲突元素</td><td>简单，适合频繁插入</td><td>指针跳转增加缓存未命中</td></tr><tr><td><strong>开放寻址法</strong></td><td>线性探测下一个空槽</td><td>缓存友好，内存紧凑</td><td>删除操作复杂</td></tr></tbody></table></li></ol><h4 id="哈希表在数据结构体系中角色"><a href="#哈希表在数据结构体系中角色" class="headerlink" title="哈希表在数据结构体系中角色"></a>哈希表在数据结构体系中角色</h4><ol><li><p><strong>核心地位</strong></p><ul><li><strong>基础数据结构</strong>： 与数组、链表、树同为构建复杂系统的基石</li><li><strong>高效操作</strong>： 平均O(1)的查找&#x2F;插入&#x2F;删除时间复杂度</li></ul></li><li><p><strong>典型应用场景</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="image-20250303105500161"></p></li><li><p><strong>进阶衍生结构</strong></p><ul><li><strong>布隆过滤器（Bloom Filter）</strong>: 概率型数据结构，用于快速判断元素不存在</li><li><strong>一致性哈希</strong>：分布式系统负载均衡的关键算法</li><li><strong>完美哈希</strong>：无冲突的静态哈希表构造方法</li></ul></li></ol><h4 id="性能优化关键点"><a href="#性能优化关键点" class="headerlink" title="性能优化关键点"></a>性能优化关键点</h4><ol><li><p><strong>负载因子（Load Factor）控制</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python字典的自动扩容策略</span></span><br><span class="line">load_factor = used_buckets / total_buckets</span><br><span class="line"><span class="comment"># 当负载因子超过2/3时触发扩容（容量翻倍）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>哈希函数设计原则</strong></p><ul><li><strong>雪崩效应</strong>： 微小输入变化导致哈希值剧烈变化</li><li><strong>避免聚焦</strong>： 防止大量Key映射到相邻索引</li></ul></li><li><p><strong>冲突处理效率</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最坏情况时间复杂度：</span><br><span class="line">- 无冲突 → O(1)</span><br><span class="line">- 全冲突 → O(n)（退化为链表） </span><br></pre></td></tr></table></figure></li></ol><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># Leetcode 146 LRU缓存</span><br><span class="line">class DLinkedNode:</span><br><span class="line">    def __init__(self, key=0, value=0):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = None</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">class LRUCache:</span><br><span class="line">    def __init__(self, capacity: int):</span><br><span class="line">        self.cache = dict()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    def _remove_node(self, node):</span><br><span class="line">        prev_node = node.prev</span><br><span class="line">        next_node = node.next</span><br><span class="line">        prev_node.next = next_node</span><br><span class="line">        next_node.prev = prev_node</span><br><span class="line"></span><br><span class="line">    def _add_to_head(self, node):</span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        self.head.next.prev = node</span><br><span class="line">        self.head.next = node</span><br><span class="line"></span><br><span class="line">    def _move_to_head(self, node):</span><br><span class="line">        self._remove_node(node)</span><br><span class="line">        self._add_to_head(node)</span><br><span class="line"></span><br><span class="line">    def get(self, key: int) -&gt; int:</span><br><span class="line">        if key not in self.cache:</span><br><span class="line">            return -1</span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self._move_to_head(node)</span><br><span class="line">        return node.value</span><br><span class="line"></span><br><span class="line">    def put(self, key: int, value: int) -&gt; None:</span><br><span class="line">        if key in self.cache:</span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self._move_to_head(node)</span><br><span class="line">        else:</span><br><span class="line">            new_node = DLinkedNode(key, value)</span><br><span class="line">            if len(self.cache) &gt;= self.capacity:</span><br><span class="line">                last_node = self.tail.prev</span><br><span class="line">                self._remove_node(last_node)</span><br><span class="line">                del self.cache[last_node.key]</span><br><span class="line">            self.cache[key] = new_node</span><br><span class="line">            self._add_to_head(new_node)</span><br></pre></td></tr></table></figure><h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><h3 id="二叉树和二叉搜索树"><a href="#二叉树和二叉搜索树" class="headerlink" title="二叉树和二叉搜索树"></a>二叉树和二叉搜索树</h3><ol><li><p><strong>二叉树（Binary Tree）</strong></p><ul><li><p><strong>定义</strong>：每个节点最多有<strong>两个子节点</strong>（左子节点和右子节点）的树形结构。</p></li><li><p><strong>特点</strong>：</p><ul><li>节点间没有顺序限制</li><li>结构灵活，可表示层次关系。</li></ul></li><li><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \   \</span><br><span class="line">D  E    F</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>二叉搜索树（Binary Search Tree， BST）</strong></p><ul><li><p><strong>定义</strong>：在二叉树基础上增加<strong>有序性约束</strong>：</p><ul><li>左子树所有节点的值<strong>小于</strong>根节点</li><li>右子树所有节点的值<strong>大于</strong>根节点</li></ul></li><li><p>特点：</p><ul><li>支持高效查找、插入、删除（平均O(log n)）</li><li>中序遍历结果为<strong>升序序列</strong></li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   / \</span><br><span class="line">  3   10</span><br><span class="line"> / \    \</span><br><span class="line">1  6    14</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="递归-vs-迭代实现二叉树"><a href="#递归-vs-迭代实现二叉树" class="headerlink" title="递归 vs 迭代实现二叉树"></a>递归 vs 迭代实现二叉树</h4><ol><li><p><strong>递归实现</strong></p><ul><li><p><strong>优点</strong>：</p><ul><li>代码简洁，逻辑直观（符合树的分形特性）</li><li>天然匹配树的层次遍历逻辑</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>栈溢出风险（深度过大时）</li><li>调试困难</li></ul></li><li><p><strong>示例（前序遍历）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(root.val)</span><br><span class="line">    preorder(root.left)</span><br><span class="line">    preorder(root.right)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>迭代实现</strong></p><ul><li><p><strong>优点</strong>：</p><ul><li>无栈溢出风险（手动控制栈&#x2F;队列）</li><li>内存使用可控</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>代码复杂度高</li><li>需要显式管理数据结构</li></ul></li><li><p><strong>示例（前序遍历）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def preorder_iterative(root):</span><br><span class="line">    stack = [root]</span><br><span class="line">    while stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        if node:</span><br><span class="line">            print(node.val)</span><br><span class="line">            stack.append(node.right)  # 右子节点先入栈</span><br><span class="line">            stack.append(node.left)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对比表</p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%AF%B9%E6%AF%94%E8%A1%A8.png" alt="image-20250314095734031"></p></li></ol><h4 id="二叉树解决的问题"><a href="#二叉树解决的问题" class="headerlink" title="二叉树解决的问题"></a>二叉树解决的问题</h4><ol><li><p><strong>数据层次化存储</strong></p><ul><li><strong>应用场景</strong>：<ul><li>文件系统目录结构</li><li>组织架构图</li><li>家谱关系</li></ul></li></ul></li><li><p><strong>高效搜索与动态操作</strong></p><ul><li><p><strong>优势对比</strong>：</p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%8A%A8%E6%80%81%E6%93%8D%E4%BD%9C.png" alt="image-20250314095950635"></p></li></ul></li><li><p><strong>特殊场景优化</strong></p><ul><li><p><strong>哈夫曼编码</strong>： 使用二叉树生成最优前缀码</p></li><li><p><strong>表达式解析</strong>： 构建语法树处理运算优先级</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">表达式 (3 + 5) * 2 对应的二叉树：</span><br><span class="line">      *</span><br><span class="line">     / \</span><br><span class="line">    +   2</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="树形结构的意义"><a href="#树形结构的意义" class="headerlink" title="树形结构的意义"></a>树形结构的意义</h4><ol><li><strong>突破线性结构限制</strong><ul><li><strong>线性结构缺陷</strong><ul><li>数组： 插入&#x2F;删除效率低（需移动元素）</li><li>链表： 随机访问效率低（需遍历）</li></ul></li></ul></li><li><strong>高效分层管理</strong><ul><li><strong>分层优势</strong><ul><li>快速缩小搜索范围（如BST每次比较排除一半子树）</li><li>自然表达包含关系（如XML&#x2F;JSON解析）</li></ul></li></ul></li><li><strong>平衡时间与空间</strong><ul><li><strong>复杂度优化</strong>：<ul><li>树结构在动态操作与查询间取得平衡</li><li>通过平衡策略（如AVL树、红黑树）保持高效</li></ul></li></ul></li></ol><h4 id="二叉搜索树的核心功能"><a href="#二叉搜索树的核心功能" class="headerlink" title="二叉搜索树的核心功能"></a>二叉搜索树的核心功能</h4><ol><li><p><strong>高效查找</strong></p><ul><li><p><strong>实现机制</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def search(root, target):</span><br><span class="line">    while root:</span><br><span class="line">        if root.val == target:</span><br><span class="line">            return True</span><br><span class="line">        elif target &lt; root.val:</span><br><span class="line">            root = root.left</span><br><span class="line">        else:</span><br><span class="line">            root = root.right</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>动态维护有序数据集</strong></p></li></ol><ul><li><p><strong>插入操作</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">root, val</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">    <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">        root.left = insert(root.left, val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        root.right = insert(root.right, val)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p><strong>范围查询与遍历</strong></p><ul><li><p><strong>中序遍历有序输出</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        inorder(root.left)</span><br><span class="line">        <span class="built_in">print</span>(root.val)</span><br><span class="line">        inorder(root.right)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>支持衍生结构</strong></p></li></ol><ul><li><strong>平衡BST</strong>: 如AVL树、红黑树，解决普通BST退化为链表的问题</li><li><strong>数据库索引</strong>：B树、B+树基于BST思想优化磁盘I&#x2F;O</li></ul><h4 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h4><ol><li><p><strong>数据库系统</strong></p><ul><li><strong>索引结构</strong>： MySQL的InnoDB引擎使用B+树（BST的扩展）加速查询</li></ul></li><li><p><strong>游戏开发</strong></p><ul><li><strong>场景管理</strong>： 四叉树（二维空间划分）优先碰撞检测</li></ul></li><li><p><strong>机器学习</strong></p><ul><li><p><strong>决策树</strong>： 二叉树结构实现分类模型</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是否购买电脑？</span><br><span class="line">├── 年龄&lt;=30 → 继续询问学生身份</span><br><span class="line">└── 年龄&gt;30 → 直接推荐购买</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="AVL树（Adelson-Velsky-and-Landis-Tree）"><a href="#AVL树（Adelson-Velsky-and-Landis-Tree）" class="headerlink" title="AVL树（Adelson-Velsky and Landis Tree）"></a>AVL树（Adelson-Velsky and Landis Tree）</h3><h4 id="AVL树的定义"><a href="#AVL树的定义" class="headerlink" title="AVL树的定义"></a>AVL树的定义</h4><p><strong>AVL树</strong>（Adelson-Velsky and Landis Tree）是最早发明的 <strong>自平衡二叉搜索树</strong>。其核心特性是通过 <strong>平衡因子</strong>（Balance Factor）维护树的平衡性，确保任意节点的左右子树高度差不超过1。</p><ul><li><strong>平衡因子</strong>：<strong>左子树高度 - 右子树高度</strong></li><li><strong>平衡规则</strong>： 每个节点的平衡因子绝对值 &lt;&#x3D; 1</li></ul><h4 id="AVL树的作用"><a href="#AVL树的作用" class="headerlink" title="AVL树的作用"></a>AVL树的作用</h4><ol><li><p><strong>防止二叉搜索树退化</strong></p><p>普通BST在插入有序数据时会退化为链表（时间复杂度从O(log n)退化为O(n)）， AVL树通过自动平衡避免这一问题。</p></li><li><p><strong>保证高效操作</strong></p><p>所有操作（查找、插入、删除）的时间复杂度稳定为O(log n)。</p></li><li><p><strong>优化数据查询场景</strong></p><p>适用于频繁查询但较少修改的场景（如数据库索引）。</p></li></ol><h4 id="AVL树-vs-二叉搜索树"><a href="#AVL树-vs-二叉搜索树" class="headerlink" title="AVL树 vs 二叉搜索树"></a>AVL树 vs 二叉搜索树</h4><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="image-20250315111048940"></p><h4 id="AVL树的核心机制"><a href="#AVL树的核心机制" class="headerlink" title="AVL树的核心机制"></a>AVL树的核心机制</h4><ol><li><p><strong>平衡因子维护</strong></p><p>每个节点额外存储<strong>高度信息</strong>，插入或删除后递归更新高度并检查平衡因子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class AVLNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line">        self.height = 1  # 新增高度属性</span><br></pre></td></tr></table></figure></li><li><p><strong>旋转操作(可能有误)</strong></p><p>当平衡因子超出±1时，通过旋转恢复平衡。共有<strong>四种旋转类型</strong>:</p><ol><li><strong>左旋（Left Rotation）</strong> ：解决右子树过高的情况。</li><li><strong>右旋（Right Rotation）</strong> ：解决左子树过高的情况。</li><li><strong>左右旋（LR Rotation）</strong> ：先左旋左子树，再右旋当前节点。</li><li><strong>右左旋（RL Rotation）</strong> ：先右旋右子树，再左旋当前节点。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def right_rotate(z):</span><br><span class="line">    y = z.left</span><br><span class="line">    T3 = y.right</span><br><span class="line"></span><br><span class="line">    y.right = z</span><br><span class="line">    z.left = T3</span><br><span class="line"></span><br><span class="line">    # 更新高度（需重新计算z和y的高度）</span><br><span class="line">    z.height = 1 + max(get_height(z.left), get_height(z.right))</span><br><span class="line">    y.height = 1 + max(get_height(y.left), get_height(y.right))</span><br><span class="line">    </span><br><span class="line">    return y  # 新的根节点</span><br></pre></td></tr></table></figure></li></ol><h4 id="AVL树解决的问题"><a href="#AVL树解决的问题" class="headerlink" title="AVL树解决的问题"></a>AVL树解决的问题</h4><ol><li><p><strong>BST的性能退化问题</strong></p><p>输入有序数据时，BST退化为链表，操作效率骤降。</p><p><strong>示例</strong>： 依次插入1，2，3，4，5， AVL树会自动平衡，而BST会变成右斜链。</p></li><li><p><strong>动态数据高效维护</strong></p><p>在频繁插入&#x2F;删除的场景中，保持稳定的查询效率。</p></li></ol><h4 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h4><ol><li><p><strong>插入操作步骤</strong></p><ol><li><strong>标准BST插入</strong>： 按二叉搜索树规则插入新节点。</li><li><strong>更新高度</strong>： 从插入点向上回溯更新祖先节点高度。</li><li><strong>检查平衡因子</strong>： 若某节点失衡， 进行旋转调整。</li></ol></li><li><p><strong>删除操作的特殊性</strong></p><ul><li>删除可能导致多个祖先节点失衡，需从删除点向上逐层检查并旋转。</li><li>时间复杂度仍为O(log n), 但实际开销比插入更大。</li></ul></li><li><p><strong>平衡代价的权衡</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%B9%B3%E8%A1%A1%E6%95%B0%E4%BB%A3%E4%BB%B7%E6%9D%83%E8%A1%A1.png" alt="image-20250315112106759"></p></li><li><p><strong>高度与节点数的关系</strong></p><p>AVL树的高度h与节点数n满足：</p><p>$$ h \leq 1.44 \log_{2}(n + 2) - 0.328 $$</p><p>这意味着即使最坏情况下，AVL树的高度仍为O(log n)。</p></li></ol><h4 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h4><ol><li><p><strong>数据库索引</strong></p><ul><li><strong>场景</strong>： MySQL的MEMORY存储引擎使用AVL树实现索引。</li><li><strong>优势</strong>： 精确范围查询和快速点查。</li></ul></li><li><p><strong>实时系统</strong></p><ul><li><strong>场景</strong>：航空管制系统中的航班优先级队列。</li><li><strong>优势</strong>： 保证最坏的情况下的操作延迟可控。</li></ul></li><li><p><strong>代码实现（插入核心逻辑）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def insert(root, key):</span><br><span class="line">    # 1. 标准BST插入</span><br><span class="line">    if not root:</span><br><span class="line">        return AVLNode(key)</span><br><span class="line">    elif key &lt; root.val:</span><br><span class="line">        root.left = insert(root.left, key)</span><br><span class="line">    else:</span><br><span class="line">        root.right = insert(root.right, key)</span><br><span class="line">    </span><br><span class="line">    # 2. 更新高度</span><br><span class="line">    root.height = 1 + max(get_height(root.left), get_height(root.right))</span><br><span class="line">    </span><br><span class="line">    # 3. 检查平衡因子</span><br><span class="line">    balance = get_balance(root)</span><br><span class="line">    </span><br><span class="line">    # 4. 处理失衡</span><br><span class="line">    # 左左失衡</span><br><span class="line">    if balance &gt; 1 and key &lt; root.left.val:</span><br><span class="line">        return right_rotate(root)</span><br><span class="line">    # 右右失衡</span><br><span class="line">    if balance &lt; -1 and key &gt; root.right.val:</span><br><span class="line">        return left_rotate(root)</span><br><span class="line">    # 左右失衡</span><br><span class="line">    if balance &gt; 1 and key &gt; root.left.val:</span><br><span class="line">        root.left = left_rotate(root.left)</span><br><span class="line">        return right_rotate(root)</span><br><span class="line">    # 右左失衡</span><br><span class="line">    if balance &lt; -1 and key &lt; root.right.val:</span><br><span class="line">        root.right = right_rotate(root.right)</span><br><span class="line">        return left_rotate(root)</span><br><span class="line">    </span><br><span class="line">    return root</span><br></pre></td></tr></table></figure></li></ol><h3 id="红黑树（Red-Black-Tree）"><a href="#红黑树（Red-Black-Tree）" class="headerlink" title="红黑树（Red-Black Tree）"></a>红黑树（Red-Black Tree）</h3><h4 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h4><p>红黑树是一种自平衡二叉搜索树，通过引入颜色标记（红色或黑色）和旋转操作，在插入和删除节点时动态调整树的结构，确保以下核心性质：</p><ol><li><p>节点颜色： 每个节点是红色或黑色</p></li><li><p>根节点： 根节点是黑色。</p></li><li><p>叶子节点（NIL）： 所有叶子节点（空节点）是黑色。</p></li><li><p>红色节点的子节点： 红色节点的子节点必须是黑色（即不允许连续红色节点）。</p></li><li><p>黑色路径一致性：从任意节点到其后代叶子节点的路径中，黑色节点的数量相同（称为”黑高”）。</p></li><li><p>红黑树定义</p><p>红黑树是一种近似平衡的二叉搜索树，通过颜色标记和规则约束，确保从根到叶子的最长路径不超过最短路径的2倍。</p></li><li><p>红黑规则</p><ol><li>每个节点为红色或黑色</li><li>根节点为黑色</li><li>叶子节点（NIL节点）为黑色</li><li>红色节点的子节点必须为黑色（无连续红节点）</li><li>从任一节点到其所有叶子节点的路径包含相同数量的黑色节点（黑高相同）</li></ol></li><li><p>与AVL树的对比</p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="image-20250315163150925"></p></li></ol><h4 id="为何实际开发更常见红黑树？"><a href="#为何实际开发更常见红黑树？" class="headerlink" title="为何实际开发更常见红黑树？"></a><strong>为何实际开发更常见红黑树？</strong></h4><p><strong>1. 性能权衡</strong></p><ul><li><strong>插入&#x2F;删除效率</strong>：红黑树的调整代价更低（旋转次数更少）<br>例如，插入时红黑树最多2次旋转，而AVL树可能需要O(log n)次旋转。</li><li><strong>综合性能</strong>：在频繁动态修改的场景中，红黑树在查询与修改间取得更好平衡。<br><strong>2. 实现简化</strong></li><li><strong>颜色标记替代高度计算</strong>：红黑树通过颜色规则简化了平衡判断逻辑，减少了维护成本。<br><strong>3. 实际应用案例</strong></li><li><strong>Java的TreeMap</strong>：基于红黑树实现键值对的有序存储。</li><li><strong>Linux内核进程调度</strong>：使用红黑树管理就绪队列，快速定位高优先级任务。</li><li><strong>C++ STL的map&#x2F;set</strong>：底层采用红黑树保障高效操作。</li></ul><h4 id="红黑树的核心操作"><a href="#红黑树的核心操作" class="headerlink" title="红黑树的核心操作"></a>红黑树的核心操作</h4><p><strong>1. 插入调整</strong><br>插入新节点（默认红色）后，可能违反红黑规则，需通过以下操作修复：</p><ul><li><strong>颜色翻转</strong>（Recoloring）</li><li><strong>旋转</strong>（Rotation）<br><strong>典型调整场景</strong>：</li></ul><ol><li><strong>叔节点为红色</strong> → 颜色翻转</li><li><strong>叔节点为黑色</strong> → 旋转 + 颜色调整<br><strong>2. 删除调整</strong><br>删除节点后，若破坏黑高规则，需通过类似插入的调整策略修复，但逻辑更复杂。<br><strong>3. 时间复杂度</strong></li></ol><ul><li>查找：O(log n)</li><li>插入&#x2F;删除：O(log n)（均摊时间）</li></ul><h4 id="总结：为何需要红黑树"><a href="#总结：为何需要红黑树" class="headerlink" title="总结：为何需要红黑树?"></a>总结：为何需要红黑树?</h4><ol><li><strong>平衡效率与实现复杂度</strong>：在保持近似平衡的前提下，减少维护成本。</li><li><strong>适应动态数据场景</strong>：适合频繁插入&#x2F;删除的场景（如数据库事务日志）。</li><li><strong>工程实践优化</strong>：相比AVL树，红黑树在综合性能上更贴近实际系统需求。</li></ol><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><h4 id="堆（Heap）的定义"><a href="#堆（Heap）的定义" class="headerlink" title="堆（Heap）的定义"></a>堆（Heap）的定义</h4><p><strong>堆</strong>是一种特殊的<strong>完全二叉树</strong>，满足以下性质：</p><ul><li><strong>堆属性</strong>： 每个节点的值 ≥（最大堆）或 ≤ （最小堆）其子节点的值。</li><li><strong>结构特性</strong>：所有层级（除最后一层）完全填充，最后一层节点尽可能左对齐。</li></ul><p>示例（最大堆）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    90</span><br><span class="line">   /  \</span><br><span class="line">  70   80</span><br><span class="line"> / \   /</span><br><span class="line">60 20 75</span><br></pre></td></tr></table></figure><h4 id="堆-vs-栈-vs-队列"><a href="#堆-vs-栈-vs-队列" class="headerlink" title="堆 vs 栈 vs 队列"></a>堆 vs 栈 vs 队列</h4><ol><li><p><strong>数据结构特性对比</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%89%B9%E6%80%A7%E5%AF%B9%E6%AF%94.png" alt="image-20250316094144214"></p></li><li><p><strong>内存管理中的“堆”与数据结构堆</strong></p><ul><li><strong>内存堆</strong>： 程序运行时动态分配内存的区域（如**malloc()**操作）。</li><li><strong>数据结构堆</strong>：一种树形结构，用于高效管理优先级。</li><li><strong>关键区别</strong>：二者概念不同，仅名称相同，功能无关联。</li></ul></li></ol><h4 id="堆的特点与不足"><a href="#堆的特点与不足" class="headerlink" title="堆的特点与不足"></a>堆的特点与不足</h4><p><strong>优点</strong></p><ol><li><strong>高效极值操作</strong>： 获取最大&#x2F;最小元素时间复杂度为O(1)。</li><li><strong>动态维护效率</strong>： 插入和删除操作时间复杂度为O(log n)。</li><li><strong>空间紧凑</strong>： 可用数组实现， 无需额外指针存储（完全二叉树特性）。</li></ol><p><strong>缺点</strong></p><ol><li><strong>不支持快速搜索</strong>： 查找非极值元素需要O(n)时间。</li><li><strong>内存占用</strong>： 数组实现需预留空间（动态数组扩容有成本）。</li><li><strong>构建成本</strong>： 将无序数组构建成堆需O(n)时间，优于逐个插入的O(n log n)。</li></ol><h4 id="堆为何是树形结构？"><a href="#堆为何是树形结构？" class="headerlink" title="堆为何是树形结构？"></a>堆为何是树形结构？</h4><ol><li><strong>层级关系需求</strong>： 堆属性要求父子节点间有明确的大小关系，树形结构天然支持这种层级比较。</li><li><strong>操作高效性</strong>：<ul><li><strong>上浮（Percolate Up）</strong>： 插入元素后， 通过树路径向上调整。</li><li><strong>下沉（Percolate Down）</strong>： 删除根节点后， 将末尾元素移至根部并向下调整。</li></ul></li><li><strong>数组实现可行性</strong>： 完全二叉树可映射到数组，无需指针（索引计算父子关系）：<ul><li>父节点索引： <strong>parent(i) &#x3D; (i-1) &#x2F;&#x2F; 2</strong></li><li>左子节点索引： <strong>left_child(i) &#x3D; 2*i + 1</strong></li><li>右子节点索引： <strong>right_child(i) &#x3D; 2*i + 2</strong></li></ul></li></ol><h4 id="堆的知识点补充"><a href="#堆的知识点补充" class="headerlink" title="堆的知识点补充"></a>堆的知识点补充</h4><ol><li><p><strong>堆的数组表示</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 最大堆示例（数组存储）</span><br><span class="line">heap = [90, 70, 80, 60, 20, 75]</span><br><span class="line"># 索引映射：</span><br><span class="line">#       0(90)</span><br><span class="line">#     /     \</span><br><span class="line">#    1(70)  2(80)</span><br><span class="line">#   /  \    /</span><br><span class="line"># 3(60)4(20)5(75)</span><br></pre></td></tr></table></figure></li><li><p><strong>堆的核心操作</strong></p><ul><li><p><strong>插入元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def heap_insert(heap, val):</span><br><span class="line">    heap.append(val)</span><br><span class="line">    idx = len(heap) - 1</span><br><span class="line">    # 上浮调整</span><br><span class="line">    while idx &gt; 0 and heap[idx] &gt; heap[(idx-1)//2]:</span><br><span class="line">        heap[idx], heap[(idx-1)//2] = heap[(idx-1)//2], heap[idx]</span><br><span class="line">        idx = (idx-1) // 2</span><br></pre></td></tr></table></figure></li><li><p><strong>删除堆顶元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def heap_extract_max(heap):</span><br><span class="line">    if not heap:</span><br><span class="line">        return None</span><br><span class="line">    max_val = heap[0]</span><br><span class="line">    heap[0] = heap[-1]</span><br><span class="line">    heap.pop()</span><br><span class="line">    idx = 0</span><br><span class="line">    # 下沉调整</span><br><span class="line">    while True:</span><br><span class="line">        left = 2*idx + 1</span><br><span class="line">        right = 2*idx + 2</span><br><span class="line">        largest = idx</span><br><span class="line">        if left &lt; len(heap) and heap[left] &gt; heap[largest]:</span><br><span class="line">            largest = left</span><br><span class="line">        if right &lt; len(heap) and heap[right] &gt; heap[largest]:</span><br><span class="line">            largest = right</span><br><span class="line">        if largest == idx:</span><br><span class="line">            break</span><br><span class="line">        heap[idx], heap[largest] = heap[largest], heap[idx]</span><br><span class="line">        idx = largest</span><br><span class="line">    return max_val</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>堆的应用场景</strong></p><ul><li><strong>堆排序：</strong> 时间复杂度O(n log n)，空间复杂度O(1)。</li><li><strong>优先队列：</strong> 操作系统进程调度、Dijkstra最短路径算法。</li><li><strong>Top K 问题：</strong> 快速找出海量数据中最大&#x2F;最小的K个元素。</li></ul></li><li><p><strong>堆的变种</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%A0%86%E7%9A%84%E5%8F%98%E7%A7%8D.png" alt="image-20250316100106536"></p></li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>堆的核心价值：</strong> 在动态数据流中高效维护极值。</li><li><strong>选择建议：</strong><ul><li>需要快速获取最大&#x2F;最小值 ➡堆</li><li>需要先进先出管理➡队列</li><li>需要后进先出管理➡栈</li></ul></li><li><strong>工程实践</strong>： 优先使用语言内置的堆实现（如Python的<strong>heapq</strong>模块）</li></ul><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><h4 id="Trie树的定义"><a href="#Trie树的定义" class="headerlink" title="Trie树的定义"></a>Trie树的定义</h4><p><strong>Trie树</strong>（发音”try”），又称<strong>前缀树</strong>或<strong>字典树</strong>，是一种专用于<strong>字符串快速检索</strong>的树形数据结构。其核心特点是<strong>利用字符串的公共前缀减少重复存储</strong>，从而实现高效查询。</p><ul><li><strong>结构特性</strong>：<ul><li>每个节点表示<strong>一个字符</strong>。</li><li>从根节点到某一节点的路径，构成该节点对应的字符串。</li><li>根节点为空字符，标记字符串的起点。</li><li>叶子节点（或特定标记节点）表示字符串的结束。</li></ul></li></ul><p><strong>示例(存储”apple”,”app”,”banana”)：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        (root)</span><br><span class="line">       /     \</span><br><span class="line">      a       b</span><br><span class="line">     /         \</span><br><span class="line">    p           a</span><br><span class="line">   / \           \</span><br><span class="line">  p   p           n</span><br><span class="line"> /     \           \</span><br><span class="line">l       l           a</span><br><span class="line"> \       \           \</span><br><span class="line">  e (★)   e (★)       n</span><br><span class="line">                     \</span><br><span class="line">                      a (★)</span><br></pre></td></tr></table></figure><h4 id="命名与核心特性"><a href="#命名与核心特性" class="headerlink" title="命名与核心特性"></a>命名与核心特性</h4><ol><li><p><strong>为什么叫Trie树？</strong></p><ul><li><strong>词源</strong>： 名称来自**”retrieval”**(检索)的中间部分，强调其高效检索的特性。</li><li>**别称：**前缀树（利用前缀共享）、字典树（类似字典按字母顺序组织）。</li></ul></li><li><p><strong>是否具有哈希表性质的树形结构？</strong></p><ul><li><p><strong>相似性</strong>：支持快速查找（类似哈希表直接通过键访问）</p></li><li><p><strong>差异性：</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%B7%AE%E5%BC%82%E6%80%A7.png" alt="image-20250316172117360"></p></li></ul></li></ol><h4 id="Trie树的核心"><a href="#Trie树的核心" class="headerlink" title="Trie树的核心"></a>Trie树的核心</h4><ol><li><strong>前缀共享</strong><ul><li><strong>机制</strong>： 不同字符串的公共前缀共享同一路径。</li><li><strong>优势</strong>： 避免重复存储，节省空间。</li></ul></li><li><strong>逐字符匹配</strong><ul><li><strong>操作逻辑</strong>： 从根节点开始， 按字符逐层向下匹配。</li><li><strong>时间复杂度</strong>： 查询、插入、删除均为<strong>O(L)</strong>（L为字符串长度）。</li></ul></li></ol><h4 id="知识点补充与细节"><a href="#知识点补充与细节" class="headerlink" title="知识点补充与细节"></a>知识点补充与细节</h4><ol><li><p><strong>节点结构设计</strong></p><ul><li><p><strong>基础节点：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.children = &#123;&#125;  <span class="comment"># 字符到子节点的映射（字典实现）</span></span><br><span class="line">        <span class="variable language_">self</span>.is_end = <span class="literal">False</span>  <span class="comment"># 标记是否为单词结尾</span></span><br><span class="line">        <span class="comment"># 可选：存储额外信息（如词频）</span></span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优化变种：</strong></p><ul><li><strong>压缩Tire树</strong>（Radix Tree）： 合并单链节点， 减少层数。</li><li><strong>三向Tire树</strong>（Ternary Search Trie）： 平衡时间与空间效率。</li></ul></li></ul></li><li><p><strong>核心操作：</strong></p><ul><li><p><strong>插入字符串：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">root, word</span>):</span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">            node.children[char] = TrieNode()</span><br><span class="line">        node = node.children[char]</span><br><span class="line">    node.is_end = <span class="literal">True</span></span><br><span class="line">    node.count += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>搜索字符串：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">root, word</span>):</span><br><span class="line">    node = root</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        node = node.children[char]</span><br><span class="line">    <span class="keyword">return</span> node.is_end</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>应用场景</strong></p><ul><li><strong>搜索引擎自动补全</strong>： 输入前缀即时提示候选词。</li><li><strong>拼写检查</strong>： 快速判断单词是否存在。</li><li><strong>路由表最长前缀匹配</strong>： IP路由选择最佳匹配规则。</li><li><strong>生物信息学</strong>： DNA序列模式匹配。</li></ul></li><li><p><strong>优缺点分析</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90.png" alt="image-20250316172958638"></p></li><li><p><strong>优化策略</strong></p><ul><li><strong>字符串映射优化</strong>： 使用数组代替字典（如仅小写字母➡长度26的数组）。</li><li><strong>延迟删除</strong>：删除操作标记节点而非立即清理路径。</li><li><strong>双数组Trie</strong>：压缩存储结构，减少内存占用。</li></ul></li></ol><h4 id="Trie树-vs-哈希表：实战对比"><a href="#Trie树-vs-哈希表：实战对比" class="headerlink" title="Trie树 vs 哈希表：实战对比"></a>Trie树 vs 哈希表：实战对比</h4><p><strong>场景： 存储100万个英文单词</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%AE%9E%E6%88%98%E5%AF%B9%E6%AF%94.png" alt="image-20250316173255409"></p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>Trie树的本质</strong>：通过树形路径表达字符串集合，核心价值在于<strong>前缀共享</strong>。</li><li><strong>适用场景</strong>： 需频繁前缀匹配、有序遍历或处理公共前缀的场景。</li><li><strong>工程选择</strong>： 若仅需精确查找且内存敏感，哈希表更优；若需前缀操作，Trie树不可替代。</li></ul><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p><strong>图论</strong>是研究**顶点（Vertex）和边（Edge）**构成的抽象结构的数学分支，用于建模事物间的关系。核心问题包括路径查找、连通性分析、网络流优化等。</p><h4 id="图的表示方法对比"><a href="#图的表示方法对比" class="headerlink" title="图的表示方法对比"></a>图的表示方法对比</h4><ol><li><p><strong>邻接矩阵（Adjacency Matrix）</strong></p><ul><li><p><strong>定义：</strong></p><p>用二维数组表示图，矩阵的行和列对应顶点，元素值表示顶点间的边。</p></li><li><p><strong>特点：</strong></p><ul><li><strong>稠密图适用</strong>：存储所有可能的边（无论是否存在）。</li><li><strong>快速查询</strong>： 判断两顶点是否相邻的时间复杂度为<strong>O(1)</strong>。</li><li><strong>空间复杂度</strong>：O(V²)（V为顶点数），适合顶点数较少的图。</li></ul></li><li><p><strong>示例</strong>（无向图）：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   顶点：A, B, C, D</span><br><span class="line">   边：A-B, A-C, B-D, C-D</span><br><span class="line">   邻接矩阵：</span><br><span class="line">      A B C D</span><br><span class="line">    A 0 1 1 0</span><br><span class="line">    B 1 0 0 1</span><br><span class="line">    C 1 0 0 1</span><br><span class="line">    D 0 1 1 0</span><br><span class="line"></span><br><span class="line">2. **邻接矩阵（Adjacency Matrix）**</span><br><span class="line"></span><br><span class="line">   - **定义：**</span><br><span class="line"></span><br><span class="line">     用数组或字典的集合表示图，每个顶点对应一个链表/数组，存储其邻接顶点。</span><br><span class="line"></span><br><span class="line">   - **特点：**</span><br><span class="line"></span><br><span class="line">     - **稀疏图适用**：仅存储实际存在的边。</span><br><span class="line">     - **节省空间**：空间复杂度为**O(V + E)**（E为边数）。</span><br><span class="line">     - **高效遍历邻接点**： 获取某顶点的所有邻接点时间复杂度为O(1)。</span><br><span class="line"></span><br><span class="line">   - **示例**（无向图）：</span><br><span class="line"></span><br><span class="line">     ```text</span><br><span class="line">     A → B → C</span><br><span class="line">     B → A → D</span><br><span class="line">     C → A → D</span><br><span class="line">     D → B → C</span><br></pre></td></tr></table></figure></li></ol><h4 id="邻接矩阵-vs-邻接表：核心对比"><a href="#邻接矩阵-vs-邻接表：核心对比" class="headerlink" title="邻接矩阵 vs 邻接表：核心对比"></a>邻接矩阵 vs 邻接表：核心对比</h4><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E6%A0%B8%E5%BF%83%E5%AF%B9%E6%AF%94.png" alt="image-20250317134922569"></p><h4 id="邻接矩阵与邻接表的关系"><a href="#邻接矩阵与邻接表的关系" class="headerlink" title="邻接矩阵与邻接表的关系"></a>邻接矩阵与邻接表的关系</h4><ol><li><strong>功能等价</strong>：两者均可完整表示图的拓扑结构。</li><li><strong>空间-时间权衡</strong>：<ul><li>邻接矩阵以空间换时间，适合快速查询。</li><li>邻接表以时间换空间，适合高效存储和遍历。</li></ul></li><li><strong>相互转化</strong>：可通过遍历边集在两种表示间转换（时间复杂度O(V²)）或O((E))。</li></ol><h4 id="知识点补充-1"><a href="#知识点补充-1" class="headerlink" title="知识点补充"></a>知识点补充</h4><ol><li><p><strong>有权图的表示</strong></p><ul><li><p><strong>邻接矩阵</strong>：矩阵元素存储边的权重（无边可设为0或∞）。</p></li><li><p><strong>邻接表</strong>： 链表节点需额外存储权重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 邻接表示例（Python字典实现有权图）</span></span><br><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>动态图的处理</strong></p><ul><li><strong>邻接矩阵</strong>：调整矩阵大小复杂（需重新分配内存）。</li><li>**邻接表：**动态增删顶点更灵活（链表&#x2F;字典天然支持动态扩展）。</li></ul></li><li><p><strong>实际应用场景</strong></p><ul><li><strong>邻接矩阵：</strong><ul><li>Floyd-Warshall算法（全源最短路径）。</li><li>小规模图的快速操作（如游戏地图的碰撞检测）。</li></ul></li><li><strong>邻接表</strong><ul><li>Dijkstra算法（单源最短路径）。</li><li>社交网络的好友关系建模。</li></ul></li></ul></li></ol><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>邻接矩阵</strong>： 空间换时间，适合稠密图和频繁边查询。</li><li><strong>邻接表</strong>：时间换空间， 适合稀疏图和高效邻接点遍历。</li><li><strong>选择依据</strong>：根据图的规模、密度和操作类型灵活选择。</li></ul><h3 id="图论的核心算法详解"><a href="#图论的核心算法详解" class="headerlink" title="图论的核心算法详解"></a>图论的核心算法详解</h3><h4 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h4><ol><li><p><strong>BFS（广度优先搜素， 层序遍历）</strong></p><ul><li><strong>核心思想</strong>： 逐层访问节点，使用队列实现。</li><li><strong>步骤</strong>：<ol><li>初始化队列，将起点入队并标记已访问。</li><li>循环出队节点，访问其未访问的邻接节点并入队。</li><li>重复直至队列为空。</li></ol></li><li><strong>时间复杂度</strong>： O(V + E)（V为顶点数， E为边数）。</li><li><strong>应用场景</strong>：<ul><li>无权图的最短路径（如迷宫问题）。</li><li>社交网络中的层级关系分析。</li></ul></li><li><strong>关键细节</strong>：<ul><li>层序遍历： 记录每层节点数可实现分层处理。</li><li>避免重复访问： 使用标记数组或哈希表。</li></ul></li></ul></li><li><p><strong>DFS（深度优先搜素，回溯剪枝）</strong></p><ul><li><p><strong>核心思想</strong>： 沿分支深入到底再回溯，使用栈或递归实现。</p></li><li><p><strong>步骤</strong>：</p><ol><li>从起点出发，标记已访问。</li><li>递归访问未访问的邻接节点。</li><li>回溯时撤销状态（用于路径记录或剪枝）。</li></ol></li><li><p><strong>时间复杂度</strong>：O(V + E).</p></li><li><p><strong>应用场景</strong>：</p><ul><li>拓扑排序、连通分量检测。</li><li>组合优化问题（如八皇后、全排列）。</li></ul></li><li><p><strong>关键细节</strong>：</p><ul><li><strong>剪枝优化</strong>： 提前终止无效分支（如约束不满足时）。</li><li><strong>非递归实现</strong>： 显式栈替代递归调用。</li></ul></li><li><p><strong>对比BFS：</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%AF%B9%E6%AF%94BFS.png" alt="image-20250318100154063"></p></li></ul></li></ol><h4 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h4><ol><li><strong>Dijkstra算法（单源最短路径，非负权图）</strong><ul><li><strong>核心思想</strong>：贪心策略，每次选择离源点最近的顶点。</li><li><strong>步骤</strong>：<ol><li>初始化距离数组，源点距离为0，其余为无穷大。</li><li>使用优先队列（最小堆）选择当前最短距离顶点。</li><li>松弛（Relax）其邻接顶点的距离。</li><li>重复直至队列为空。</li></ol></li><li><strong>时间复杂度</strong>：O((V + E) log V)（y优先队列优化）。</li><li><strong>限制</strong>： 无法处理负权边。</li><li><strong>关键细节</strong>：<ul><li><strong>优先队列优化</strong>：避免每次遍历查找最小距离。</li><li><strong>负权陷阱</strong>：负权边会导致已确定最短路径的顶点被错误更新。</li></ul></li></ul></li><li><strong>Floyd-Warshall算法（全源最短路径， 动态规划）</strong><ul><li><strong>核心思想</strong>： 动态规划，逐步允许通过中间顶点。</li><li><strong>步骤</strong>：<ol><li>初始化距离矩阵为图的邻接矩阵。</li><li>三重循环更新： <strong>dist[i][j] &#x3D; min(dist[i][j], dist[i][k] + dist[k][j])</strong>。</li><li>最终矩阵保存所有顶点对的最短距离。</li></ol></li><li><strong>时间复杂度</strong>： $$O(V^3)$$。</li><li><strong>应用场景</strong>：<ul><li>小规模图的全源最短路径。</li><li>可处理负权边（但不允许负权环）。</li></ul></li><li><strong>关键细节</strong>：<ul><li><strong>空间优化</strong>： 原地更新矩阵， 无额外空间。</li><li><strong>路径重建</strong>： 记录前驱矩阵回溯路径。</li></ul></li></ul></li></ol><p><strong>Dijkstra vs Floyd:</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/Dijkstra_vs_Floyd.png" alt="image-20250318101509169"></p><h4 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h4><ol><li><strong>Prim 算法 （适合稠密图）</strong><ul><li><strong>核心思想</strong>： 贪心策略，逐步扩展生成树。</li><li><strong>步骤</strong>：<ol><li>任选起点，初始化优先队列（存储边权）。</li><li>选择当前最小权边连接的顶点加入生成树。</li><li>更新队列中与新加入顶点邻接的边。</li><li>重复直至所有顶点加入。</li></ol></li><li><strong>时间复杂度</strong>：<ul><li>邻接矩阵： $$O(V^2)$$。</li><li>优先队列优化：$$O(E log V)$$。</li></ul></li><li><strong>关键细节</strong>：<ul><li><strong>与Dijlstra相似性</strong>：均使用优先队列，但Prim更新的是到生成树的距离而非到源点的距离。</li><li><strong>稠密图优化</strong>： 邻接矩阵实现更高效。</li></ul></li></ul></li><li><strong>Kruskal算法（适合稀疏图）</strong><ul><li><strong>核心思想</strong>：按边权升序选择，避免环。</li><li><strong>步骤</strong>：<ol><li>将所有边按权值排序。</li><li>依次选择最小边，若两端点不在同一连通分量则加入生成树。</li><li>使用并查集（Union-Find）检测环。</li></ol></li><li><strong>时间复杂度</strong>： $$O(ElogE)$$（主要开销在排序）。</li><li><strong>关键细节</strong>：<ul><li><strong>并查集优化</strong>： 路径压缩和按秩合并降低时间复杂度。</li><li><strong>适用场景</strong>： 边数远小于顶点数平方时更高效。</li></ul></li></ul></li></ol><p><strong>Prim vs Kruskal:</strong></p><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/Prim_vs_Kruskal.png" alt="image-20250318102637757"></p><h4 id="关键对比与总结"><a href="#关键对比与总结" class="headerlink" title="关键对比与总结"></a>关键对比与总结</h4><p><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/python_imgs/%E5%85%B3%E9%94%AE%E5%AF%B9%E6%AF%94%E4%B8%8E%E6%80%BB%E7%BB%93.png" alt="image-20250318102705028"></p><h4 id="实战应用示例"><a href="#实战应用示例" class="headerlink" title="实战应用示例"></a>实战应用示例</h4><p><img src="C:\Users\ccxx\AppData\Roaming\Typora\typora-user-images\image-20250318102748032.png" alt="image-20250318102748032"></p><h2 id="算法范式"><a href="#算法范式" class="headerlink" title="算法范式"></a>算法范式</h2><ol><li><p><strong>分治算法</strong></p><ul><li>归并排序的实现</li><li>最大子数组问题（LeetCode 53）</li></ul></li><li><p><strong>贪心算法</strong></p><ul><li>区间调度问题</li><li>霍夫曼编码实现</li></ul></li><li><p><strong>动态规划</strong></p><p>动态规划（Dynamic Programming，DP）是一种通过将复杂问题分解为重叠子问题，并利用子问题的最优解来构造全局最优解的算法范式。其核心思想是<strong>避免重复计算</strong>。</p><ul><li>0-1背包问题（空间优化版本）</li><li>股票买卖系列（LeetCode 121-123）</li><li>编辑距离（状态转移方程推导）</li></ul></li><li><p><strong>回溯算法</strong></p><ul><li>全排列问题（剪枝优化）</li><li>N皇后问题（位运算优化）</li></ul></li></ol></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://leccxx-maker.github.io/ccxx">leccxx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://leccxx-maker.github.io/ccxx/2025/11/19/%E5%AD%A6%E4%B9%A0python/">https://leccxx-maker.github.io/ccxx/2025/11/19/%E5%AD%A6%E4%B9%A0python/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/ccxx/tags/%E7%BB%83%E4%B9%A0/">练习</a></div><div class="post-share"><div class="social-share" data-image="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/ccxx/2025/11/17/K8s%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/" title="K8s集群自动化部署与管理平台"><img class="cover" src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" onerror='onerror=null,src="/ccxx/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">K8s集群自动化部署与管理平台</div></div><div class="info-2"><div class="info-item-1">K8s集群自动化部署与管理平台涉及技术栈： 容器编排：Kubernetes 1.28, Calico CNI 自动化工具：Helm，kubeadm, kubectl 脚本开发：Python, Shell CI&#x2F;CD: GitLab（模拟实现） 容器运行时：Docker 监控运维：监控脚本 123456Kubernetes（常简称为K8s首次发布2014年6月7日）是用于自动部署...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/ccxx/2025/11/17/2025-11-18-Dockerfile-and-YAML-file/" title="Dockerfile and YAML file"><img class="cover" src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-18</div><div class="info-item-2">Dockerfile and YAML file</div></div><div class="info-2"><div class="info-item-1">Dockerfile与YAML文件编写练习Dockerfile编写练习 基础Nginx镜像1234# 基于官方Nginx镜像，添加自定义HTML页面FROM nginx:alpineCOPY index.html /usr/share/nginx/html/EXPOSE 80 Python Flask应用12345678# 构建Python Flask应用镜像FROM python:3.9...</div></div></div></a><a class="pagination-related" href="/ccxx/2025/11/17/2025-11-18-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8ESQL%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/" title="数据清洗与SQL语法练习"><img class="cover" src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-18</div><div class="info-item-2">数据清洗与SQL语法练习</div></div><div class="info-2"><div class="info-item-1">数据清洗与SQL语法练习初级题目 缺失值处理 编写Python脚本，读取包含学生成绩的CSV文件，检测并处理缺失值: 数值型字段用该列均值填充 文本型字段用”未知”填充 输出处理前后的数据统计信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152...</div></div></div></a><a class="pagination-related" href="/ccxx/2025/11/17/Ubuntu%20for%20Linux%20%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/" title="Ubuntu for Linux 基础练习"><img class="cover" src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-18</div><div class="info-item-2">Ubuntu for Linux 基础练习</div></div><div class="info-2"><div class="info-item-1">Ubuntu for Linux 基础练习Ubuntu操作练习基础操作 用户和权限管理 创建新用户testuser并设置密码 将该用户添加到sudo组 创建一个共享目录/home/shared,设置权限775，确保该组用户有读写权限 1234567891011121314151617181920212223242526272829### 相关操作# 创建用户组zdffgroupsudo ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/avatar/avatar.jpg" onerror='this.onerror=null,this.src="/ccxx/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">leccxx</div><div class="author-info-description">Not having dreams that are impossible to achieve.</div><div class="site-data"><a href="/ccxx/archives/"><div class="headline">Articles</div><div class="length-num">5</div></a><a href="/ccxx/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/ccxx/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leccxx-maker"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/leccxx-maker" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:25225ccxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来到我的博客！这里记录我在 Python、容器和 Linux 领域的学习笔记。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0python%E7%9A%84%E8%AE%A1%E5%88%92"><span class="toc-number">1.</span> <span class="toc-text">学习python的计划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%A7%84%E5%88%92"><span class="toc-number">1.1.</span> <span class="toc-text">初步规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.</span> <span class="toc-text">每日总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-11-20"><span class="toc-number">1.2.1.</span> <span class="toc-text">2024&#x2F;11&#x2F;20</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-11-21"><span class="toc-number">1.2.2.</span> <span class="toc-text">2024&#x2F;11&#x2F;21</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-11-22"><span class="toc-number">1.2.3.</span> <span class="toc-text">2024&#x2F;11&#x2F;22</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-11-23"><span class="toc-number">1.2.4.</span> <span class="toc-text">2024&#x2F;11&#x2F;23</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%EF%BC%88chatgpt%EF%BC%89"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">九九乘法表（chatgpt）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B01-%E5%9F%BA%E6%9C%AC%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8"><span class="toc-number">1.2.4.1.1.</span> <span class="toc-text">实现1 基本九九乘法表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B02-%E5%AF%B9%E9%BD%90%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8"><span class="toc-number">1.2.4.1.2.</span> <span class="toc-text">实现2 对齐九九乘法表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B03-%E5%B0%81%E8%A3%85%E4%B8%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.1.3.</span> <span class="toc-text">实现3 封装为函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B04-%E5%8A%A8%E6%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B9%98%E6%B3%95%E8%A1%A8"><span class="toc-number">1.2.4.1.4.</span> <span class="toc-text">实现4 动态可扩展乘法表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B05-%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.4.1.5.</span> <span class="toc-text">实现5 结果保存到文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.4.1.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F-chatgpt"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">猜数游戏(chatgpt)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-11-24"><span class="toc-number">1.2.5.</span> <span class="toc-text">2024&#x2F;11&#x2F;24</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-12-02"><span class="toc-number">1.2.6.</span> <span class="toc-text">2024&#x2F;12&#x2F;02</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-12-04"><span class="toc-number">1.2.7.</span> <span class="toc-text">2024&#x2F;12&#x2F;04</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-12-11"><span class="toc-number">1.2.8.</span> <span class="toc-text">2024&#x2F;12&#x2F;11</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-12-12"><span class="toc-number">1.2.9.</span> <span class="toc-text">2024&#x2F;12&#x2F;12</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">递归和迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-12-14"><span class="toc-number">1.2.10.</span> <span class="toc-text">2024&#x2F;12&#x2F;14</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2024-12-27"><span class="toc-number">1.2.11.</span> <span class="toc-text">2024&#x2F;12&#x2F;27</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.11.1.</span> <span class="toc-text">扩展赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2025-2-8"><span class="toc-number">1.2.12.</span> <span class="toc-text">2025&#x2F;2&#x2F;8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2025-2-21"><span class="toc-number">1.2.13.</span> <span class="toc-text">2025&#x2F;2&#x2F;21</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2025-2-23"><span class="toc-number">1.2.14.</span> <span class="toc-text">2025&#x2F;2&#x2F;23</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2025-2-28"><span class="toc-number">1.2.15.</span> <span class="toc-text">2025&#x2F;2&#x2F;28</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">《数据结构与算法 python语言实现》练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">1.3.1.</span> <span class="toc-text">第一章</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">第二章</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.4.</span> <span class="toc-text">算法和数据结构的学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">1.4.1.</span> <span class="toc-text">前缀和算法思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">核心方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">递归和迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">核心概念对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%88Recursion%EF%BC%89"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">递归（Recursion）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%EF%BC%88Iteration%EF%BC%89"><span class="toc-number">1.4.2.1.2.</span> <span class="toc-text">迭代（Iteration）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">执行机制对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">经典案例对比分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">阶乘计算</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-array"><span class="toc-number">1.5.1.</span> <span class="toc-text">数组(array)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84-vs-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">静态数组 vs 动态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E8%B4%A8"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">动态数组的实质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">数据类型约束本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">关键概念对比表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">常见误区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%88Linked-List"><span class="toc-number">1.5.2.</span> <span class="toc-text">链表（Linked List)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8%EF%BC%88Linked-List%EF%BC%89"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">什么是链表（Linked List）?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">链表的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">链表存在的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E6%8A%80%E5%B7%A7%EF%BC%88Dummy-Node%EF%BC%89"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">哨兵节点技巧（Dummy Node）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">链表节点的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">指针在链表中的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-vs-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">数组 vs 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">1.5.2.7.1.</span> <span class="toc-text">关键对比表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.5.3.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">栈与队列的本质定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">关键实现细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">典型应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%86%B3%E7%AD%96%E6%A0%91"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">选择决策树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%93%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%9C%B0%E4%BD%8D"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">在数据结构体现中的地位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA%E8%AD%A6%E7%A4%BA"><span class="toc-number">1.5.3.6.</span> <span class="toc-text">常见误区警示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Hash-Table%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">哈希表（Hash Table）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Hash-Table%EF%BC%89%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">哈希表（Hash Table）的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">哈希函数的核心特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%93%88%E5%B8%8C%E6%80%A7%EF%BC%88Hashability%EF%BC%89%E5%88%A4%E6%96%AD"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">可哈希性（Hashability）判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">哈希表的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB%E4%B8%AD%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.4.5.</span> <span class="toc-text">哈希表在数据结构体系中角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">1.5.4.6.</span> <span class="toc-text">性能优化关键点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.5.</span> <span class="toc-text">经典问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">树形结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.6.1.</span> <span class="toc-text">二叉树和二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-vs-%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">递归 vs 迭代实现二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">二叉树解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">树形结构的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">二叉搜索树的核心功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">实际应用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL%E6%A0%91%EF%BC%88Adelson-Velsky-and-Landis-Tree%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">AVL树（Adelson-Velsky and Landis Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AVL%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">AVL树的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AVL%E6%A0%91%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">AVL树的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AVL%E6%A0%91-vs-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">AVL树 vs 二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AVL%E6%A0%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">AVL树的核心机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AVL%E6%A0%91%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">AVL树解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85"><span class="toc-number">1.6.2.6.</span> <span class="toc-text">知识点补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.2.7.</span> <span class="toc-text">实战应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88Red-Black-Tree%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">红黑树（Red-Black Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">什么是红黑树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E6%9B%B4%E5%B8%B8%E8%A7%81%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">为何实际开发更常见红黑树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">红黑树的核心操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">总结：为何需要红黑树?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">堆（Heap）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%EF%BC%88Heap%EF%BC%89%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">堆（Heap）的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86-vs-%E6%A0%88-vs-%E9%98%9F%E5%88%97"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">堆 vs 栈 vs 队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">堆的特点与不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E4%B8%BA%E4%BD%95%E6%98%AF%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">堆为何是树形结构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">堆的知识点补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.6.4.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie%E6%A0%91"><span class="toc-number">1.6.5.</span> <span class="toc-text">Trie树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">Trie树的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">命名与核心特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie%E6%A0%91%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">Trie树的核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">知识点补充与细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trie%E6%A0%91-vs-%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9A%E5%AE%9E%E6%88%98%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.5.5.</span> <span class="toc-text">Trie树 vs 哈希表：实战对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.6.5.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.7.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">图的表示方法对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-vs-%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">邻接矩阵 vs 邻接表：核心对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">邻接矩阵与邻接表的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85-1"><span class="toc-number">1.7.0.4.</span> <span class="toc-text">知识点补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.7.0.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.7.1.</span> <span class="toc-text">图论的核心算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">遍历算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">最短路径算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">最小生成树算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AF%B9%E6%AF%94%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">关键对比与总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">实战应用示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">算法范式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/ccxx/2025/11/19/%E5%AD%A6%E4%B9%A0python/" title="学习Python"><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" onerror='this.onerror=null,this.src="/ccxx/img/404.jpg"' alt="学习Python"></a><div class="content"><a class="title" href="/ccxx/2025/11/19/%E5%AD%A6%E4%B9%A0python/" title="学习Python">学习Python</a><time datetime="2025-11-19T16:00:00.000Z" title="Created 2025-11-20 00:00:00">2025-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ccxx/2025/11/17/2025-11-18-Dockerfile-and-YAML-file/" title="Dockerfile and YAML file"><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" onerror='this.onerror=null,this.src="/ccxx/img/404.jpg"' alt="Dockerfile and YAML file"></a><div class="content"><a class="title" href="/ccxx/2025/11/17/2025-11-18-Dockerfile-and-YAML-file/" title="Dockerfile and YAML file">Dockerfile and YAML file</a><time datetime="2025-11-17T16:00:00.000Z" title="Created 2025-11-18 00:00:00">2025-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ccxx/2025/11/17/2025-11-18-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8ESQL%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/" title="数据清洗与SQL语法练习"><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" onerror='this.onerror=null,this.src="/ccxx/img/404.jpg"' alt="数据清洗与SQL语法练习"></a><div class="content"><a class="title" href="/ccxx/2025/11/17/2025-11-18-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8ESQL%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/" title="数据清洗与SQL语法练习">数据清洗与SQL语法练习</a><time datetime="2025-11-17T16:00:00.000Z" title="Created 2025-11-18 00:00:00">2025-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ccxx/2025/11/17/Ubuntu%20for%20Linux%20%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/" title="Ubuntu for Linux 基础练习"><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" onerror='this.onerror=null,this.src="/ccxx/img/404.jpg"' alt="Ubuntu for Linux 基础练习"></a><div class="content"><a class="title" href="/ccxx/2025/11/17/Ubuntu%20for%20Linux%20%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/" title="Ubuntu for Linux 基础练习">Ubuntu for Linux 基础练习</a><time datetime="2025-11-17T16:00:00.000Z" title="Created 2025-11-18 00:00:00">2025-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ccxx/2025/11/17/K8s%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/" title="K8s集群自动化部署与管理平台"><img src="https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/lake-tahoe-1658659.jpg" onerror='this.onerror=null,this.src="/ccxx/img/404.jpg"' alt="K8s集群自动化部署与管理平台"></a><div class="content"><a class="title" href="/ccxx/2025/11/17/K8s%E9%9B%86%E7%BE%A4%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/" title="K8s集群自动化部署与管理平台">K8s集群自动化部署与管理平台</a><time datetime="2025-11-17T16:00:00.000Z" title="Created 2025-11-18 00:00:00">2025-11-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://myblog-ccxx.oss-cn-hangzhou.aliyuncs.com/site_imgs/mushrooms-9946579.jpg)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By leccxx</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/ccxx/js/utils.js?v=5.5.2"></script><script src="/ccxx/js/main.js?v=5.5.2"></script><div class="js-pjax"></div><script async data-pjax src="/ccxx/"></script></div></body></html>